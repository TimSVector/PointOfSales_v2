// ---------------------------------------------------------------------------
// Copyright Vector Informatik GmbH 2025. All rights reserved.
//
// This file is provided by Vector Informatik GmbH (https://www.vector.com) for
// use with PC-lint Plus. Redistribution is permitted but any redistribution
// must preserve this notice and, if the redistributed file has been modified,
// provide notice that the file has been modified from the original.
// ---------------------------------------------------------------------------

// au-misra4.lnt -- Author options - MISRA C 2023

/*
    This options file can be used to explicitly activate those
    checks advocated by the Motor Industry Software Reliability
    Association.

    You can use this file directly when linting your programs as in:

    lint au-misra4.lnt hello.c

    Vector Informatik GmbH relies on the document, "MISRA C:2023:
    Guidelines for the use of the C language in critical systems",
    copyright 2023 by The MISRA Consortium Limited, as the primary
    source for this file. Vector Informatik GmbH makes no warranty
    as to the completeness or applicability of this options file and
    reserves the right to amend or alter the official contents of
    such at any time.

    "MISRA" is a registered trademark of The MISRA Consortium Limited.

 */

/* version check */ -cond('%PCLP_NO_LNT_VERSION_CHECK%' != '1' && (%LINT_MAJOR_VERSION% != 2025 || %LINT_MINOR_VERSION% != 0),
    +fatal_error(This configuration file is intended for PC-lint Plus 2025.
                 You are attempting to use it with PC-lint Plus %LINT_MAJOR_VERSION%.%LINT_MINOR_VERSION%.
                 It is recommended that you use configuration files intended
                 for PC-lint Plus %LINT_MAJOR_VERSION%.%LINT_MINOR_VERSION%.)
)

/* Add an indication to message 900 that this file was employed */
    -append(900,[MISRA C:2023])


/**** Dir 1.1 (Req) ************/

    /* not statically checkable */

/**** Dir 2.1 (Req) ************/

    -std(c99) 		       /* strict ISO C99 */
    /* Note: if you code to the C90, C11, or C17 standard instead, you
       may want to comment out the above option and uncomment the
       appropriate option below. You will also want to do likewise for
       other uses of the '-std(c99)' option throughout this file. */
    // -std(c90)
    // -std(c11)
    // -std(c17)

/**** Dir 3.1 (Req) ************/

    /* not statically checkable */

/**** Dir 4.1 (Req) ************/

    /* not statically checkable */

/**** Dir 4.2 (Adv) ************/

    /* not statically checkable */

/**** Dir 4.3 (Req) ************/

    /* 9220 - assembly language instruction is not encapsulated in a function */
    +e9220
    +elib(9220)
    -append(9220,[MISRA C:2023 Directive 4.3, required])

    /* 9221 - function mixes assembly code with non-assembly code */
    +e9221
    +elib(9221)
    -append(9221,[MISRA C:2023 Directive 4.3, required])

/**** Dir 4.4 (Adv) ************/

    /* This requirement (that there be no commented-out code) is, in
       principle, not statically checkable.  The reason given for the
       requirement is that comments do not nest.  Thus a commented
       out section of code that happens to use slash-star commenting
       could inadvertently introduce unwanted code.  Rule 3.1, however,
       addresses the nested comment issue and hence the major concern
       that this requirement seeks to address is indeed checkable.
     */
    -fnc                   /* flag nested comments */
    +e602                  /* comment within comment */
    +elib(602)
    -append(602,[MISRA C:2023 Directive 4.4, advisory])

    /* The message 9155 uses a heuristic approach to diagnose commented-out code. */
    +e9155                  /* comment may contain commented-out code */
    +elib(9155)
    -append(9155,[MISRA C:2023 Directive 4.4, advisory])

/**** Dir 4.5 (Adv) ************/

    +fta            /* enable typographical ambiguity checking */
    +e9046	  	    /* typographical ambiguity */
    +elib(9046)
    -append(9046,[MISRA C:2023 Directive 4.5, advisory])

/**** Dir 4.6 (Adv) ************/

    +e970               /* flag modifiers used outside of typedefs */
    +elib(970)
    -append(970,[MISRA C:2023 Directive 4.6, advisory])
    -estring(970,bool)
    -estring(970,_Bool)
    -estring(970,char)

/**** Dir 4.7 (Req) ************/

    +e534               /* ignoring return value of function */
    +elib(534)
    -append(534,[MISRA C:2023 Directive 4.7, required])

/**** Dir 4.8 (Adv) ************/

    +e9045               /* non-hidden definition of type */
    +elib(9045)
    -append(9045,[MISRA C:2023 Directive 4.8, advisory])

/**** Dir 4.9 (Adv) ************/

    +e9026               /* function-like macro defined */
    +elib(9026)
    -append(9026,[MISRA C:2023 Directive 4.9, advisory])

/**** Dir 4.10 (Req) ************/

    +e451             /* Header repeatedly included without guard */
    +elib(451)
    -append(451,[MISRA C:2023 Directive 4.10, required])

/**** Dir 4.11 (Req) ************/

    /* The arguments to over 100 calls to standard library functions
       are monitored; users can specify additional constraints for
       other functions.
     */

    +e418 /* passing null pointer to function */
    +elib(418)
    -append(418,[MISRA C:2023 Directive 4.11, required])

    +e668 /* possibly passing null pointer to function */
    +elib(668)
    -append(668,[MISRA C:2023 Directive 4.11, required])

    +e419 /* apparent data overrun for function symbol */
    +elib(419)
    -append(419,[MISRA C:2023 Directive 4.11, required])

    +e669 /* possible data overrun for function symbol */
    +elib(669)
    -append(669,[MISRA C:2023 Directive 4.11, required])

    +e420 /* apparent access beyond array for function symbol */
    +elib(420)
    -append(420,[MISRA C:2023 Directive 4.11, required])

    +e670 /* possible access beyond array for function symbol */
    +elib(670)
    -append(670,[MISRA C:2023 Directive 4.11, required])

    +e422 /* passing to function a negative value */
    +elib(422)
    -append(422,[MISRA C:2023 Directive 4.11, required])

    +e671 /* possibly passing to function a negative value */
    +elib(671)
    -append(671,[MISRA C:2023 Directive 4.11, required])

    +e2423 /* apparent domain error for function symbol, argument outside of accepted range */
    +elib(2423)
    -append(2423,[MISRA C:2023 Directive 4.11, required])

    +e2623 /* possible domain error for function symbol, argument outside of accepted range */
    +elib(2623)
    -append(2623,[MISRA C:2023 Directive 4.11, required])

    +e2460 /* literal provided as argument to function */
    +elib(2460)
    -append(2460,[MISRA C:2023 Directive 4.11, required])

    +e2960 /* integer constant expression provided as argument to function */
    +elib(2960)
    -append(2960,[MISRA C:2023 Directive 4.11, required])

    +e857 /* argument 1 is not compatible with argument 2 in call to function */
    +elib(857)
    -append(857,[MISRA C:2023 Directive 4.11, required])

/**** Dir 4.12 (Req) ************/

    +e586       /* Symbol is deprecated */
    +elib(586)
    -deprecate(function,calloc)
    -append(586(calloc),[MISRA C:2023 Directive 4.12, required])
    -deprecate(function,malloc)
    -append(586(malloc),[MISRA C:2023 Directive 4.12, required])
    -deprecate(function,realloc)
    -append(586(realloc),[MISRA C:2023 Directive 4.12, required])
    -deprecate(function,free)
    -append(586(free),[MISRA C:2023 Directive 4.12, required])

/**** Dir 4.13 (Adv) ************/

    /* Mutexes and Lockers */
    +e454       /* mutex locked without being unlocked */
    +elib(454)
    -append(454,[MISRA C:2023 Directive 4.13, advisory])
    +e455       /* mutex unlocked without being locked */
    +elib(455)
    -append(455,[MISRA C:2023 Directive 4.13, advisory])
    +e456       /* multiple execution paths combined with different lock states */
    +elib(456)
    -append(456,[MISRA C:2023 Directive 4.13, advisory])
    +e459       /* function accesses shared variable outside protection of mutex */
    +elib(459)
    -append(459,[MISRA C:2023 Directive 4.13, advisory])
    +e460       /* thread unsafe function called while mutually unprotected */
    +elib(460)
    -append(460,[MISRA C:2023 Directive 4.13, advisory])
    +e461       /* thread unsafe functions called outside protection of common mutex */
    +elib(461)
    -append(461,[MISRA C:2023 Directive 4.13, advisory])
    +e2462       /* mutex lock order mismatch */
    +elib(2462)
    -append(2462,[MISRA C:2023 Directive 4.13, advisory])
    +e2492       /* locker already locked */
    +elib(2492)
    -append(2492,[MISRA C:2023 Directive 4.13, advisory])
    +e2493       /* locker not locked */
    +elib(2493)
    -append(2493,[MISRA C:2023 Directive 4.13, advisory])

    /* File Streams */
    +e2471       /* operation on stream that has been closed */
    +elib(2471)
    -append(2471,[MISRA C:2023 Directive 4.13, advisory])
    +e2474       /* attempt to flush stream that is not open for writing */
    +elib(2474)
    -append(2474,[MISRA C:2023 Directive 4.13, advisory])
    +e2475       /* attempt to flush stream after an input operation */
    +elib(2475)
    -append(2475,[MISRA C:2023 Directive 4.13, advisory])
    +e2476       /* attempt to perform read operation on stream not opened for reading */
    +elib(2476)
    -append(2476,[MISRA C:2023 Directive 4.13, advisory])
    +e2477       /* attempt to perfrom write operation on stream not opened for reading */
    +elib(2477)
    -append(2477,[MISRA C:2023 Directive 4.13, advisory])
    +e2478       /* attempt to perform read operation on stream after write without an intervening flush or reposition */
    +elib(2478)
    -append(2478,[MISRA C:2023 Directive 4.13, advisory])
    +e2479       /* attempt to peform write operation on stream after read without an intervening reposition */
    +elib(2479)
    -append(2479,[MISRA C:2023 Directive 4.13, advisory])

    /* Random Number Generator */
    +e2461       /* rand/random used without any explicit call to srand/srandom */
    +elib(2461)
    -append(2461,[MISRA C:2023 Directive 4.13, advisory])

    /* Dynamic Memory */
    +e429       /* custodial pointer neither free'd nor returned */
    +elib(429)
    -append(429,[MISRA C:2023 Directive 4.13, advisory])
    +e593       /* custodial pointer possibly not free'd nor returned */
    +elib(593)
    -append(593,[MISRA C:2023 Directive 4.13, advisory])
    +e449       /* memory was likely previously deallocated */
    +elib(449)
    -append(449,[MISRA C:2023 Directive 4.13, advisory])
    +e2434       /* memory was potentially deallocated */
    +elib(2434)
    -append(2434,[MISRA C:2023 Directive 4.13, advisory])
    +e815       /* unsaved pointer used in pointer arithmetic */
    +elib(815)
    -append(815,[MISRA C:2023 Directive 4.13, advisory])

/**** Dir 4.14 (Req) ************/

    /* Not currently supported */

/**** Dir 4.15 (Req) ************/

    /* Not currently supported */

/**** Dir 5.1 (Req) ************/

    +e457     /* a variable was accessed by two threads in an unsafe way outside of the protection of a mutex */
    +elib(457)
    -append(457,[MISRA C:2023 Directive 5.1, required])

/**** Dir 5.2 (Req) ************/

    +e2462  /* mutex lock order mismatch */
    +elib(2462)
    -append(2462,[MISRA C:2023 Directive 5.2, required])

/**** Dir 5.3 (Req) ************/

    +e586        /* to activate the deprecation message */
    -deprecate(function,thrd_create)
    -append(586(thrd_create),[MISRA C:2023 Directive 5.3, required])

/**** Rule 1.1 (Req) ************/

    -std(c99) 		       /* strict ISO C99 */
    /* Note: if you code to the C90, C11, or C17 standard instead, you
       may want to comment out the above option and uncomment the
       appropriate option below. You will also want to do likewise for
       other uses of the '-std(c99)' option throughout this file. */
    // -std(c90)
    // -std(c11)
    // -std(c17)
    /* Note: appended citation text is not applied to errors
       reporting violations of the C language. */

    /* See the -lang_limit option. */
    +e793     /* language limit exceeded */
    +elib(793)
    -append(793,[MISRA C:2023 Rule 1.1, required])

/**** Rule 1.2 (Adv) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    -std(c99) 		       /* strict ISO C99 */
    /* Note: if you code to the C90, C11, or C17 standard instead, you
       may want to comment out the above option and uncomment the
       appropriate option below. You will also want to do likewise for
       other uses of the '-std(c99)' option throughout this file. */
    // -std(c90)
    // -std(c11)
    // -std(c17)

/**** Rule 1.3 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */

    /* Avoid the use of undefined or unspecified behavior as described in:
       - ISO C Appendix A
       - ISO C90 Annex G
       - ISO C99 Annex J
     */

    /* Improper non-empty source file ending
       (ISO C, Appendix A.6.2, point 1)
       (ISO C90, Annex G.2, point 1)
       (ISO C99, Annex J.2, point 2).
     */
    +e783   /* line does not end with newline */
    +elib(783)
    -append(783, [MISRA C:2023 Rule 1.3, required])
    +e1   /* unclosed comment */
    +elib(1)
    -append(1, [MISRA C:2023 Rule 1.3, required])

    /* Main function ill-formed
       (ISO C99, Annex J.2, point 4).
     */
    +e2447   /* main has bad specifier */
    +elib(2447)
    -append(2447, [MISRA C:2023 Rule 1.3, required])
    +e2448   /* main should return int */
    +elib(2448)
    -append(2448, [MISRA C:2023 Rule 1.3, required])

    /* Non-standard character encountered in source code
       (ISO C, Appendix A.6.2, point 2)
       (ISO C90, Annex G.2, point 2)
       (ISO C99, Annex J.2, point 5).
     */
    +e9423   /* non-basic character used in identifier */
    +elib(9423)
    -append(9423, [MISRA C:2023 Rule 1.3, required])

    /* Comment, string literal, character constant,
       or header name contains inappropriate multibyte
       character
       (ISO C, Appendix A.6.2, point 3)
       (ISO C90, Annex G.2, point 3)
       (ISO C99, Annex J.2, point 6).
     */
    +e972   /* unusual character in char/string literal */
    +elib(972)
    -append(972, [MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 4.1 and Rule 20.10 */

    /* Repeated label within a function
       (ISO C, Appendix A.6.2, point 5)
       (ISO C90, Annex G.2, point 5).
     */
    +e31   /* symbol redefinition */
    +elib(31)
    -append(31,[MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 5.2. */

    /* Non-visible identifier used
       (ISO C, Appendix A.6.2, point 6)
       (ISO C90, Annex G.2, point 6).
     */
    +e40   /* undeclared identifier */
    +elib(40)
    -append(40,[MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 17.3 */

    /* Identifiers for the same entity differ beyond the minimal
       significant characters
       (ISO C, Appendix A.6.2, point 7)
       (ISO C90, Annex G.2, point 7).
       See Rule 5.1, Rule 5.2, Rule 5.4, and Rule 5.5.
     */

    /* The same identifier has both internal and external linkage in
       the same translation unit
       (ISO C, Appendix A.6.2, point 8)
       (ISO C90, Annex G.2, point 8)
       (ISO C99, Annex J.2, point 7).
     */
    +e401   /* symbol not previously declared static */
    +elib(401)
    -append(401,[MISRA C:2023 Rule 1.3, required])

    /* Using automatic storage data via a pointer after the data's
       lifetime
       (ISO C, Appendix A.6.2, point 10)
       (ISO C90, Annex G.2, point 9)
       (ISO C99, Annex J.2, point 8, point 9).
       See Dir 4.12, Rule 18.6, and Rule 21.3
     */

    /* Using the value of uninitialized automatic object
       (ISO C, Appendix A.6.2, point 41)
       (ISO C90, Annex G.2, point 41)
       (ISO C99, Annex J.2, point 10).
       See Rule 9.1
     */

    /* Non-character type lvalue expression read
       trap representation
       (ISO C99, Annex J.2, point 11).
       See Rule 9.1, Rule 11.2, Rule 11.3, Rule 11.4,
       Rule 11.5, and Rule 19.1.
     */

    /* Side effect produced trap representation
       modifies object via non-character type
       lvalue expression
       (ISO C99, Annex J.2, point 12).
       See Rule 11.2, Rule 11.3, Rule 11.4, and Rule 11.5.
     */

    /* Expression operand(s) may produce negative
       zero result, implementation does not support
       negative zero
       (ISO C99, Annex J.2, point 13).
       See Rule 9.1, Rule 10.1, Rule 11.2, Rule 11.3,
       Rule 11.4, Rule 11.5, and Rule 19.1.
     */

    /* Incompatible redeclarations
       (ISO C, Appendix A.6.2, point 11)
       (ISO C90, Annex G.2, point 10)
       (ISO C99, Annex J.2, point 14).
       See Rule 5.6, Rule 5.7, and Rule 8.3
     */

    /* Value not representable in range
       (ISO C, Appendix A.6.2, point 16)
       (ISO C90, Annex G.2, point 15)
       (ISO C99, Annex J.2, point 15, point 16).
     */
    +e86   /* structure has no data elements */
    +elib(86)
    -append(86,[MISRA C:2023 Rule 1.3, required])

    /* Lvalue does not designate object
       (ISO C99, Annex J.2, point 17).
       See Rule 9.1, Rule 11.2, Rule 11.3, Rule 11.4,
       Rule 11.5, and Rule 19.1
     */

    /* Incomplete type used where complete
       type is required
       (ISO C, Appendix A.6.2, point 17)
       (ISO C90, Annex G.2, point 16)
       (ISO C99, Annex J.2 point 18).
     */

    /* Pointer into register storage class array
       (ISO C99, Annex J.2, point 19).
    */

    /* Use or conversion of void expression
       (ISO C, Appendix A.6.2, point 18)
       (ISO C90, Annex G.2, point 17)
       (ISO C99, Annex J.2, point 20).
     */
    +e792   /* casting void expression to void */
    +elib(792)
    -append(792, [MISRA C:2023 Rule 1.3, required])

    /* Pointer to integer conversion produces
       out of range result
       (ISO C99, Annex J.2, point 21).
       See Rule 11.1, Rule 11.2,
       Rule 11.4, and Rule 11.6.
    */
    +e2453   /* incompatible pointer to integer conversion */
    +elib(2453)
    -append(2453, [MISRA C:2023 Rule 1.3, required])

    /* Pointer to pointer conversion produces
       bad alignment
       (ISO C99, Annex J.2, point 22).
       See Rule 11.2, Rule 11.3, and Rule 11.5.
     */
    +e2445   /* cast increases required alignment */
    +elib(2445)
    -append(2445, [MISRA C:2023 Rule 1.3, required])

    /* Function pointer and pointed-to function
       have incompatible types
       (ISO C, Appendix A.6.2, point 28)
       (ISO C90, Annex G.2, point 27)
       (ISO C99, Annex J.2, point 23).
     */
    +e466   /* conversion to/from prototypeless function pointer */
    +elib(466)
    -append(466, [MISRA C:2023 Rule 1.3, required])
    +e2455   /* incompatible function pointer types */
    +elib(2455)
    -append(2455, [MISRA C:2023 Rule 1.3, required])
    +e9237   /* conversion between function pointer and different non-integral pointer */
    +elib(9237)
    -append(9237, [MISRA C:2023 Rule 1.3, required])
     /* Also, see Rule 11.1 */

    /* Unclosed quotes
       (ISO C, Appendix A.6.2, point 4)
       (ISO C90, Annex G.2, point 4)
       (ISO C99, Annex J.2, point 24).
     */
    +e2     /* unclosed quote */
    +elib(2)
    -append(2,[MISRA C:2023 Rule 1.3, required])

    /* Reserved keyword used for some other purpose
       (ISO C99, Annex J.2, point 25).
       Not currently supported.
     */

    /* Non-standard universal character name in
       identifier
       (ISO C99, Annex J.2, point 26).
     */
    +e9443   /* universal char name used in identifier */
    +elib(9443)
    -append(9443, [MISRA C:2023 Rule 1.3, required])

    /* Initial character in identifier is universal
       character digit
       (ISO C99, Annex J.2, point 27).
     */
    +e9443   /* universal char name usd in identifier */
    +elib(9443)
    -append(9443, [MISRA C:2023 Rule 1.3, required])

    /* Identifiers for the same entity differ beyond the minimal
       significant characters
       (ISO C, Appendix A.6.2, point 7)
       (ISO C90, Annex G.2, point 7)
       (ISO C99, Annex J.2, point 28).
       See Rule 5.1, Rule 5.2, Rule 5.4, and Rule 5.5.
     */

    /* Identifier __func__ explicitly declared
       (ISO C99, Annex J.2, point 29).
       See Rule 21.2.
     */

    /* Non-standard escape sequence
       (ISO C, Appendix A.6.2, point 12)
       (ISO C90, Annex G.2, point 11).
     */
    +e606   /* non-ANSI escape sequence */
    +elib(606)
    -append(606,[MISRA C:2023 Rule 1.3, required])

    /* Attempt to modify string literal
       (ISO C, Appendix A.6.2, point 13)
       (ISO C90, Annex G.2, point 12)
       (ISO C99, Annex J.2, point 30).
       See Rule 7.4, Rule 11.4, and Rule 11.8.
     */

    /* Character string literal adjacent to wide
       string literal
       (ISO C, Appendix A.6.2, point 14)
       (ISO C90, Annex G.2, point 13).
     */
    +e707   /* concatenation mixes narrow and wide string literals */
    +elib(707)
    -append(707, [MISRA C:2023 Rule 1.3, required])
    +e1107   /* invalid concatenation of differing wide string literals */
    +elib(1107)
    -append(1107, [MISRA C:2023 Rule 1.3, required])

    /* Non-standard character in header name
       (ISO C, Appendix A.6.2, point 15)
       (ISO C90, Annex G.2, point 14)
       (ISO C99, Annex J.2, point 31).
       See Rule 20.2
     */

    /* Modifying an object more than once or modifying and accessing
       between two sequence points
       (ISO C, Appendix A.6.2, point 19)
       (ISO C90, Annex G.2, point 18)
       (ISO C99, Annex J.2, point 32).
       See Rule 13.2, Rule 13.3, and Rule 13.4
     */

    /* Invalid arithmetic operations or unrepresentable results
       (ISO C, Appendix A.6.2, point 20)
       (ISO C90, Annex G.2, point 19)
       (ISO C99, Annex J.2, point 33).
     */
    +e54   /* division by 0 */
    +elib(54)
    -append(54,[MISRA C:2023 Rule 1.3, required])
    +e414   /* possible division by 0 */
    +elib(414)
    -append(414,[MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 12.4 */

    /* Value of object accessed not by lvalue
       of allowable type
       (ISO C, Appendix A.6.2, point 21)
       (ISO C90, Annex G.2, point 20)
       (ISO C99, Annex J.2, point 34).
       See Rule 11.3, Rule 11.4, and Rule 11.5.
     */

    /* Attempted to modify result of function call,
       conditional/assignment/comma operator, or
       access it after next sequence point
       (ISO C99, Annex J.2, point 35).
     */
        /* Not currently supported. */

    /* Passing void argument to function
       (ISO C, Appendix A.6.2, point 22)
       (ISO C90, Annex G.2, point 21).
       Not currently supported.
     */

    /* Function without prototype called where number
       of arguments and number of parameters do
       not match
       (ISO C, Appendix A.6.2, point 23)
       (ISO C90, Annex G.2, point 22)
       (ISO C99, Annex J.2, point 36).
       See Rule 8.2 and Rule 17.3.
     */

    /* Variable argument function called,
       no prototype ending with ellipsis
       (ISO C, Appendix A.6.2, point 26)
       (ISO C90, Annex G.2, point 25)
       (ISO C99, Annex J.2, point 37).
       See Rule 8.4, Rule 8.5, Rule 11.1,
       Rule 17.3, and Rule 21.2.
     */

    /* Function call without function prototype;
       after promotion, types of arguments do not
       agree with types of parameters
       (ISO C, Appendix A.6.2, point 24)
       (ISO C90, Annex G.2, point 23)
       (ISO C99, Annex J.2, point 38).
       See Rule 8.2 and Rule 17.3.
     */

    /* Function called with prototype; function
       definition not of compatible type
       (ISO C, Appendix A.6.2, point 25)
       (ISO C90, Annex G.2, point 24)
       (ISO C99, Annex J.2, point 39).
       See Rule 5.6, Rule 5.7, Rule 8.2, Rule 8.3,
       Rule 8.4, Rule 8.5, Rule 11.1, and Rule 21.2.
     */

    /* An invalid array reference, null pointer reference, or
       reference to an object declared with automatic storage duration in
       a terminated block occurs
       (ISO C, Appendix A.6.2, point 27)
       (ISO C90, Annex G.2, point 26)
       (ISO C99, Annex J.2, point 40).
     */
    +e413   /* likely use of null pointer */
    +elib(413)
    -append(413,[MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 17.6 and Rule 18.1 */

    /* A pointer to a function is converted to a pointer to an object
       or a pointer to an object is converted to a pointer to a function
       (ISO C, Appendix A.6.2, point 29)
       (ISO C90, Annex G.2, point 28).
     */
    +e2454  /* incompatible pointer types */
    +elib(2454)
    -append(2454,[MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 11.1 */

    /* Pointer converted to non-pointer/non-integral type
       (ISO C, Appendix A.6.2, point 30)
       (ISO C90, Annex G.2, point 29)
       (ISO C99, Annex J.2, point 41).
     */
    /* See Rule 11.1, Rule 11.2, Rule 11.6,
       and Rule 11.7.
     */

    /* Second operand of / or % is zero
       (ISO C99, Annex J.2, point 42).
     */
    +e54   /* division/remainder by 0 */
    +elib(54)
    -append(54,[MISRA C:2023 Rule 1.3, required])
    +e414   /* possible division/remainder by 0 */
    +elib(414)
    -append(414,[MISRA C:2023 Rule 1.3, required])
     /* Also, see Dir 4.1. */

    /* Addition/subtraction on non-array pointer
       (ISO C, Appendix A.6.2, point 31)
       (ISO C90, Annex G.2, point 30)
       (ISO C99, Annex J.2, point 43).
       See Rule 18.1.
     */
    +e2662   /* arithmetic on possible non-array pointer */
    +elib(2662)
    -append(2662,[MISRA C:2023 Rule 1.3, required])

    /* Pointer arithmetic producing out of range
       result dereferenced
       (ISO C99, Annex J.2, point 44).
       See Rule 18.1.
     */

    /* Pointers that do not point to same array subtracted
       (ISO C, Appendix A.6.2, point 32)
       (ISO C90, Annex G.2, point 31)
       (ISO C99, Annex J.2, point 45).
       See Rule 18.2.
     */

    /* Array subscript out of range
       (ISO C99, Annex J.2, point 46).
       See Rule 18.1.
     */

    /* Expression shifted by inappropriate amount
       (ISO C, Appendix A.6.2, point 33)
       (ISO C90, Annex G.2, point 32)
       (ISO C99, Annex J.2, point 48).
       See Rule 12.2
     */

    /* Pointers that do not point to same aggregate/
       union compared
       (ISO C, Appendix A.6.2, point 34)
       (ISO C90, Annex G.2, point 33)
       (ISO C99, Annex J.2, point 50).
       See Rule 18.3.
     */

    /* Object assigned to overlapping object
       (ISO C, Appendix A.6.2, point 35)
       (ISO C90, Annex G.2, point 34)
       (ISO C99, Annex J.2, point 51).
       See Rule 19.1.
     */

    /* Non-integer type or bad operands for
       expression that must be an integer
       constant expression
       (ISO C99, Annex J.2, point 52).
       See Dir 4.14, Rule 10.1, Rule 18.8.
     */

    /* Constant expression in initializer is
       not appropriate type
       (ISO C99, Annex J.2, point 53).
     */
    +e34   /* non-compile time constant initializer */
    +elib(34)
    -append(34,[MISRA C:2023 Rule 1.3, required])

    /* Arithmetic constant expression does not have
       arithmetic type or has bad operands
       (ISO C99, Annex J.2, point 54).
     */
        /* Not currently supported. */

    /* Value of object accessed in creating address constant
       (ISO C99, Annex J.2, point 55).
     */
        /* Not currently supported. */

    /* An identifier for an object is declared with no linkage and the
       type of the object is incomplete after its declarator, or after its
       init-declarator if it has an initializer
       (ISO C, Appendix A.6.2, point 36)
       (ISO C90, Annex G.2, point 35)
       (ISO C99, Annex J.2, point 56).
     */
    +e86   /* structure has no data elements */
    +elib(86)

    /* Declaring a function at block scope with a storage-class
       specifier other than extern
       (ISO C, Appendix A.6.2, point 37)
       (ISO C90, Annex G.2, point 36)
       (ISO C99, Annex J.2, point 57).
     */
    +e629   /* static class for function */
    +elib(629)
    -append(629,[MISRA C:2023 Rule 1.3, required])

    /* Structure or union defined as containing only
       unnamed members
       (ISO C90, Annex G.2, point 37)
       (ISO C99, Annex J.2, point 58).
     */
        /* Not currently supported. */

    /* A bit-field is declared with a type other than int, signed int,
       or unsigned int
       (ISO C, Appendix A.6.2, point 38)
       (ISO C90, Annex G.2, point 38).
       See Rule 6.1.
     */

    /* Access/creation of pointer to just past flexible
       array member of structure; referenced object
       provides no elements for array
       (ISO C99, Annex J.2, point 59).
       See Rule 18.7.
     */

    /* Incomplete type not completed within scope
       requiring complete definition
       (ISO C99, Annex J.2, point 60).
     */
    +e115   /* struct/union not defined */
    +elib(115)
    -append(115,[MISRA C:2023 Rule 1.3, required])

    /* Attempted modification of const type via lvalue
       with non-const type
       (ISO C, Appendix A.6.2, point 39)
       (ISO C90, Annex G.2, point 39)
       (ISO C99, Annex J.2, point 61).
       See Rule 11.4, Rule 11.8, and
       Rule 19.2.
     */

    /* Attempted reference of volatile type via lvalue
       with non-volatile type
       (ISO C, Appendix A.6.2, point 40)
       (ISO C90, Annex G.2, point 40)
       (ISO C99, Annex J.2, point 62).
       See Rule 11.4, Rule 11.8, and
       Rule 19.2.
     */

    /* Specification of function type includes 
       type qualifiers
       (ISO C99, Annex J.2, point 63).
     */
    +e2705   /* ineffective qualifier on return type */
    +elib(2705)
    -append(2705,[MISRA C:2023 Rule 1.3, required])

    /* Qualified types required to be compatible do
       not have identically qualified version of
       compatible type
       (ISO C99, Annex J.2, point 64).
       Not currently supported.
     */

    /* Modified object accessed through restrict
       qualified pointer to const qualified type,
       or through restrict-qualified pointer and
       another pointer not based on the same object
       (ISO C99, Annex J.2, point 65).
       See Rule 8.14.
     */

    /* Restrict qualified pointer assigned value
       based on other restricted pointer whose
       block neither began execution before block
       of this pointer, nor ended before assignment
       (ISO C99, Annex J.2, point 66).
       See Rule 8.14.
     */

    /* External linkage function declared with inline
       function specifier, but also not defined in same TU
       (ISO C99, Annex J.2, point 67).
       See Rule 8.10.
     */
     +estring(2701, "function")   /* function declared outside of header not defined in source file */
     +elib(2701)
     -append(2701, [MISRA C:2023 Rule 1.3, required])

    /* Pointer types required to be compatible not
       identically qualified, or are not pointers
       to compatible types
       (ISO C99, Annex J.2, point 68).
     */
    +e2452  /* signed integer pointer converted to/from unsigned equivalent */
    +elib(2452)
    -append(2452,[MISRA C:2023 Rule 1.3, required])
    +e2454  /* incompatible pointer types */
    +elib(2454)

    /* Size expression in array declaration
       not a constant expression, evaluates
       to nonpositive value
       (ISO C99, Annex J.2, point 69).
       See Rule 18.8.
     */

    /* Two array types that must be compatible
       do not have compatible element types or
       have unequal size specifiers
       (ISO C99, Annex J.2, point 70).
       See Rule 18.8.
     */

    /* Declaration of array parameter
       includes keyword static within
       [], corresponding argument
       does not provide access to first
       element of array with at least the
       specified number of elements
       (ISO C99, Annex J.2, point 71).
       See Rule 17.6.
     */

    /* Storage-class specifier or type
       qualifier modifies keyword void as
       function parameter type list
       (ISO C99, Annex J.2, point 72).
     */

    /* Functions that must be compatible
       do not have compatible return types
       or have mismathced parameters
       (ISO C99, Annex J.2, point 73).
       See Rule 8.2 and Rule 11.1.
     */

    /* Initializer for scalar neither
       single expression nor single
       expression enclosed in braces
       (ISO C99, Annex J.2, point 75).
     */
    +e576   /* excess elements in initializer */
    +elib(576)
    -append(576,[MISRA C:2023 Rule 1.3, required])

    /* An object with aggregate or union type with static storage
       duration has a non-brace-enclosed initializer, or an object
       with aggregate or union type with automatic storage duration
       has either a single expression initializer with a type other
       than that of the object or a non-brace-enclosed initializer
       (ISO C, Appendix A.6.2, point 42)
       (ISO C90, Annex G.2, point 42)
       (ISO C99, Annex J.2, point 76, point 77).
       See Rule 9.2.
     */

    /* Multiple definitions for the same externally linked identifier
       (ISO C, Appendix A.6.2, point 9)
       (ISO C90, Annex G.2, point 44)
       (ISO C99, Annex J.2, point 78).
       See Rule 8.6.
     */
    +e31   /* symbol redefinition */
    +elib(31)

    /* Function definition includes
       identifier list, but types of
       parameters are not declared in
       following declaration list
       (ISO C99, Annex J.2, point 79).
       See Rule 8.2.
     */

    /* Adjusted parameter type in function
       definition not an object type
       (ISO C99, Annex J.2, point 80).
     */
        /* Not currently supported. */

    /* A function that accepts a variable number of arguments is
       defined without a parameter type list that ends with the
       ellipsis notation
       (ISO C, Appendix A.6.2, point 44)
       (ISO C90, Annex G.2, point 45)
       (ISO C99, Annex J.2, point 81).
       See Rule 17.1
     */

    /* The value of a function is used, but no value was returned
       (ISO C, Appendix A.6.2, point 43)
       (ISO C90, Annex G.2, point 43)
       (ISO C99, Annex J.2, point 82).
       See Rule 17.4.
     */

    /* An identifier for an object with internal linkage and an
       incomplete type is declared with a tentative definition
       (ISO C, Appendix A.6.2, point 45)
       (ISO C90, Annex G.2, point 46)
       (ISO C99, Annex J.2, point 83).
     */
    +e86   /* structure has no data elements */
    +elib(86)

    /* Token defined generated during
       expansion of #if/#elif directive
       (ISO C, Appendix A.6.2, point 46)
       (ISO C90, Annex G.2, point 47)
       (ISO C99, Annex J.2, point 84).
     */
    +e491   /* non-standard use of 'defined' PP operator */
    +elib(491)
    -append(491,[MISRA C:2023 Rule 1.3, required])

    /* Non-standard #include directive
       (ISO C, Appendix A.6.2, point 47)
       (ISO C90, Annex G.2, point 48)
       (ISO C99, Annex J.2, point 85).
       See Rule 20.3.
     */

    /* #include directive character sequence 
       does not start with a letter
       (ISO C99, Annex J.2, point 86).
     */
        /* Not currently supported. */

    /* Macro argument consists of no PP token
       (ISO C, Appendix A.6.2, point 48)
       (ISO C90, Annex G.2, point 49).
     */
        /* Not currently supported. */

    /* Macro arguments have sequences of PP tokens
       that would otherwise act as directive lines
       (ISO C, Appendix A.6.2, point 49)
       (ISO C90, Annex G.2, point 50)
       (ISO C99, Annex J.2, point 87).
       See Rule 20.6.
     */

    /* Result of PP operator # not a valid character
       string literal
       (ISO C, Appendix A.6.2, point 50)
       (ISO C90, Annex G.2, point 51)
       (ISO C99, Annex J.2, point 88).
       See Rule 20.10.
     */

    /* Result of PP concatenation operator ##
       not a valid PP token
       (ISO C, Appendix A.6.2, point 51)
       (ISO C90, Annex G.2, point 52)
       (ISO C99, Annex J.2, point 89).
       See Rule 20.10.
     */
    +e2446   /* pasting formed invalid PP token */
    +elib(2446)
    -append(2446, [MISRA C:2023 Rule 1.3, required])

    /* Non-standard #line directive
       (ISO C, Appendix A.6.2, point 52)
       (ISO C90, Annex G.2, point 53)
       (ISO C99, Annex J.2, point 90).
     */
    +"estring(10,a numeric constant)"  /* expecting a numeric constant */

    /* Non-STDC #pragma directive documented as
       causing UB encountered
       (ISO C99, Annex J.2, point 91).
     */
    +e975   /* unknown pragma will be ignored */
    +elib(975)
    -append(975, [MISRA C:2023 Rule 1.3, required])

    /* STDC pragma does not match one of the
       well-defined forms
       (ISO C99, Annex J.2, point 92).
     */
        /* Not currently supported. */

    /* #defining or #undefing any of: defined, __LINE__, __FILE__,
       __DATE__, __TIME__, or __STDC__
       (ISO C, Appendix A.6.2, point 53)
       (ISO C90, Annex G.2, point 54)
       (ISO C99, Annex J.2, point 93).
       See Rule 21.1
     */

    /* File with same name as non-implementation
       defined standard header placed in standard
       search location for included source files
       (ISO C99, Annex J.2, point 95).
       Not currently supported.
     */

    /* Erroneous inclusion of standard header
       (ISO C, Appendix A.6.2, point 56)
       (ISO C90, Annex G.2, point 56).
       See Rule 17.3, Rule 20.1, Rule 20.4, and Rule 21.2.
     */

    /* Header file inclusion within external
       declaration or definition
       (ISO C99, Annex J.2, point 96).
       See Rule 20.1.
     */

    /* Function, object, type, or macro
       declared/defined in standard header
       used before inclusion
       (ISO C99, Annex J.2, point 97).
       See Rule 20.1 and Rule 21.2.
     */

    /* Macro named a keyword before
       standard header inclusion
       (ISO C99, Annex J.2, point 98).
       See Rule 20.4.
     */

    /* Redefinition of reserved external identifier
       (ISO C, Appendix A.6.2, point 55)
       (ISO C90, Annex G.2, point 57)
       See Rule 21.1 and Rule 21.2.
     */

    /* Program specific declaration of library
       function does not have external linkage
       (ISO C99, Annex J.2, point 99).
       See Rule 21.2.
     */

    /* Declaration/definition of reserved identifier
       (ISO C99, Annex J.2, point 100).
       See Rule 21.1 and Rule 21.2.
     */

    /* Undefinition of macro beginning with underscore
       and uppercase letter/another underscore
       (ISO C99, Annex J.2, point 101).
       See Rule 21.1.
     */

    /* Library function argument has invalid
       value, unless behavior is specified
       (ISO C, Appendix A.6.2, point 59)
       (ISO C90, Annex G.2, point 60)
       (ISO C99, Annex J.2, point 102).
       See Dir 4.11.
     */

    /* Pointer passed to library function
       array parameter yields invalid
       address computations and/or object accesses
       (ISO C99, Annex J.2, point 103).
       See Dir 4.11.
     */

    /* Variable argument library function not declared
       (ISO C, Appendix A.6.2, point 60)
       (ISO C90, Annex G.2, point 61).
       See Rule 17.3 and Rule 21.2.
     */

    /* Assert definition suppressed to access function
       (ISO C, Appendix A.6.2, point 61)
       (ISO C90, Annex G.2, point 62)
       (ISO C99, Annex J.2, point 104).
       See Rule 21.1.
     */

    /* Non-scalar assert argument
       (ISO C99, Annex J.2, point 105).
     */

    /* STDC pragma used in inappropriate context
       (ISO C99, Annex J.2, point 106).
     */

    /* Argument to character handling function is
       out of domain
       (ISO C, Appendix A.6.2, point 62)
       (ISO C90, Annex G.2, point 63)
       (ISO C99, Annex J.2, point 107).
       See Rule 21.13 and Dir 4.11.
     */

    /* Errno definition suppressed to access object
       (ISO C, Appendix A.6.2., point 57)
       (ISO C90, Annex G.2, point 58)
       (ISO C99, Annex J.2, point 108).
       See Rule 21.1 and Rule 21.2.
     */

     /* Inappropriate mask argument to function
        providing access to FP status flags
        (ISO C99, Annex J.2, point 110).
        See Rule 21.12.
      */

    /* Fesetexceptflag used to set FP status flags
       not specified in fegetexceptflag call that
       produced correspoding fexcept_t object
       (ISO C99, Annex J.2, point 111).
       See Rule 21.12.
     */

    /* Argument to fesetenv or feupdateenv neither
       object set by call to fegetenv/feholdexcept,
       nor environment macro
       (ISO C99, Annex J.2, point 112).
       See Dir 4.11.
     */

    /* Result of atof, atoi, or atol cannot be represented
       (ISO C, Appendix A.6.2, point 89)
       (ISO C90, Annex G.2, point 90).
       See Rule 21.7.
     */

    /* Result of integer arithmetic or conversion function
       cannot be represented
       (ISO C99, Annex J.2, point 113).
       See Dir 4.14.
     */

    /* Modification of string pointed to by setlocale
       return value
       (ISO C99, Annex J.2, point 114).
       See Rule 21.19.
     */

    /* Modification of structure pointed to by localeconv
       return value
       (ISO C99, Annex J.2, point 115).
       See Rule 21.19.
     */

    /* Macro definition of math_errhandling suppressed
       or identifier of same name defined
       (ISO C99, Annex J.2, point 116).
       See Rule 21.1, 21.2.
     */

    /* Non-floating type argument to FP classification
       or comparison macro
       (ISO C99, Annex J.2, point 117).
     */

    /* Macro definition of setjmp suppressed to obtain
       access to function, or identifier of same name defined
       (ISO C, Appendix A.6.2, point 63)
       (ISO C90, Annex G.2, point 64)
       (ISO C99, Annex J.2, point 118).
       See Rule 21.1., Rule 21.2, and Rule 21.4.
     */

    /* Invocation of setjmp macro in inappropriate context
       (ISO C, Appendix A.6.2, point 64)
       (ISO C90, Annex G.2, point 65)
       (ISO C99, Annex J.2, point 119).
       See Rule 21.4.
     */

    /* longjmp function invoked to restore nonexistent
       environment
       (ISO C99, Annex J.2, point 120).
       See Rule 21.4.
     */

    /* Object of automatic storage class without
       volatile-qualified type changed between setjmp
       and longjmp call, then value accessed
       (ISO C, Appendix A.6.2, point 65)
       (ISO C90, Annex G.2, point 66)
       (ISO C99, Annex J.2, point 121)
       See Rule 21.4.
     */

    /* longjmp invoked from nested signal routine
       (ISO C, Appendix A.6.2, point 66)
       (ISO C90, Annex G.2, point 67).
       See Rule 21.4 or Rule 21.5.
     */

    /* Invalid pointer to signal handler function
       (ISO C99, Annex J.2, point 122).
       See Rule 21.5.
     */

    /* Signal handler returns when signal corresponded
       to computational exception
       (ISO C99, Annex J.2, point 123).
       See Rule 21.5.
     */

    /* Signal occurs as result of calling abort or raise
       function, signal handler calls raise function
       (ISO C99, Annex J.2, point 124).
       See Rule 21.5.
     */

    /* Signal occurs other than as result of call to abort
       or raise function, signal handler calls inappropriate
       standard library function or incorrectly refers to
       object with static storage
       (ISO C, Appendix A.6.2, point 67)
       (ISO C90, Annex G.2, point 68)
       (ISO C99, Annex J.2, point 125).
       See Rule 21.5.
     */

    /* Value of errno referred to after signal occurs other
       than as result of calling abort or raise function;
       corresponding signal handler calls signal function
       such that return value is SIG_ERR
       (ISO C, Appendix A.6.2, point 68)
       (ISO C90, Annex G.2, point 69)
       (ISO C99, Annex J.2, point 126).
       See Rule 21.5.
     */

    /* Signal generated by asynchronous signal handler
       (ISO C99, Annex J.2, point 127).
       See Rule 21.5.
     */

    /* Function attempts to access varying arguments not using
       va_list object/before va_start invocation
       (ISO C99, Annex J.2, point 128).
       See Rule 17.1.
     */

    /* va_arg invoked with parameter ap that was passed to
       function that invoked same macro with same parameter
       (ISO C, Appendix A.6.2, point 69)
       (ISO C90, Annex G.2, point 70)
       (ISO C99, Annex J.2, point 129).
       See Rule 17.1.
     */

    /* Definition of va_start, va_arg, va_copy, or va_end
       suppressed to access function, or external identifier
       with name va_copy or va_end defined
       (ISO C, Appendix A.6.2, point 70)
       (ISO C90, Annex G.2, point 71)
       (ISO C99, Annex J.2, point 130).
       See Rule 17.1, Rule 21.1, and Rule 21.2.
     */

    /* va_end invoked without corresponding va_start
       (ISO C, Appendix A.6.2, point 74)
       (ISO C90, Annex G.2, point 75)
       (ISO C99, Annex J.2, point 131).
       See Rule 17.1.
     */

    /* Return occurs from variable argument list function
       initialized by va_start before va_end invocation
       (ISO C, Appendix A.6.2, point 75)
       (ISO C90, Annex G.2, point 76).
       See Rule 17.1.
     */

    /* Type parameter to va_arg not such that pointer to
       object of same type can be obtained by postfixing a *
       (ISO C99, Annex J.2, point 132).
       See Rule 17.1.
     */

    /* va_arg invoked with no next argument, or with type
       not compatible with type of next argument
       (ISO C, Appendix A.6.2, point 72, point 73)
       (ISO C90, Annex G.2, point 73, point 74)
       (ISO C99, Annex J.2, point 133).
       See Rule 17.1.
     */

    /* va_copy or va_start called to initialize va_list
       previously initialized by either macro without
       intervening invocation of va_end
       (ISO C99, Annex J.2, point 134).
       See Rule 17.1.
     */

    /* Parameter parmN of va_start declared with register
       storage class or incorrect type
       (ISO C, Appendix A.6.2, point 71)
       (ISO C90, Annex G.2, point 72)
       (ISO C99, Annex J.2, point 135).
       See Rule 17.1.
     */

    /* Parameter member-designator of offsetof is invalid
       right operand of . for type parameter or designates
       bit-field member
       (ISO C, Appendix A.6.2, point 58)
       (ISO C90, Annex G.2, point 59)
       (ISO C99, Annex J.2, point 136).
     */
    +e1013   /* symbol not a member of class */
    +elib(1013)
    -append(1013, [MISRA C:2023 Rule 1.3, required])

    /* Argument to integer-constant macro is not decimal,
       octal, or hexadecimal constant, or has value exceeding
       limits for corresponding type
       (ISO C99, Annex J.2, point 137).
     */
    +e2505   /* inappropriate integer constant macro arg */
    +elib(2505)
    -append(2505, [MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 7.5. */

    /* Byte IO function applied to wide-oriented stream, or
       vice versa
       (ISO C99, Annex J.2, point 138).
       See Rule 21.6.
     */
    +e2480   /* byte-oriented operation called with wide-oriented file stream */
    +elib(2480)
    -append(2480, [MISRA C:2023 Rule 1.3, required])
    +e2481   /* wide-oriented operation called with byte-oriented file stream */
    +elib(2481)
    -append(2481, [MISRA C:2023 Rule 1.3, required])

    /* Used segment of file beyond most recent wide character
       written to wide-oriented stream
       (ISO C99, Annex J.2, point 139).
       See Rule 21.6.
     */

    /* Pointer to FILE object dereferenced after associated
       file was closed
       (ISO C99, Annex J.2, point 140).
       See Rule 21.6 or Rule 22.6.
     */

    /* Stream for fflush function points to stream in which
       most recent operation was input
       (ISO C, Appendix A.6.2, point 76)
       (ISO C90, Annex G.2, point 77)
       (ISO C99, Annex J.2, point 141).
     */
    +e2475   /* flush stream after input */
    +elib(2475)
    -append(2475, [MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 21.6. */

    /* String pointed to by mode argument for fopen does not
       match one of specified character sequences
       (ISO C99, Annex J.2, point 142).
     */
    +e2472   /* non-standard character in mode argument */
    +elib(2472)
    -append(2472, [MISRA C:2023 Rule 1.3, required])
    +e2473   /* mode argument not a legal file open mode */
    +elib(2473)
    -append(2473, [MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 21.6. */

    /* Output op on stream followed by input op without flush
       or file positioning, or vice versa
       (ISO C, Appendix A.6.2, point 77)
       (ISO C90, Annex G.2, point 78)
       (ISO C99, Annex J.2, point 143).
     */
    +e2478   /* read after write without flush/reposition */
    +elib(2478)
    -append(2478, [MISRA C:2023 Rule 1.3, required])
    +e2479   /* write after read without reposition */
    +elib(2479)
    -append(2479, [MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 21.6. */

    /* Attempted to use contents of array supplied by setvbuf
       (ISO C99, Annex J.2, point 144).
       See Rule 21.6.
     */

    /* An aggregate or union, or a pointer to an aggregate or union is
       an argument to the fprintf function, except for the conversion
       specifiers %s (for an array of character type) or %p (for a pointer
       to void)
       (ISO C, Appendix A.6.2, point 84)
       (ISO C90, Annex G.2, point 85).
     */
    +e437   /* passing struct to ellipsis */
    +elib(437)
    -append(437,[MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 21.6 */

    /* Format-argument mismatch in an fprintf or fscanf type of
       function
       (ISO C, Appendix A.6.2, point 78)
       (ISO C90, Annex G.2, point 79)
       (ISO C99, Annex J.2, point 145).
     */
    +e558   /* too few arguments */
    +elib(558)
    -append(558,[MISRA C:2023 Rule 1.3, required])
    +e719   /* too many arguments */
    +elib(719)
    -append(719,[MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 21.6 */

    /* Format in call to formatted IO function, strftime, or
       wcsftime not valid multibyte character sequence that
       begins and ends in its initial shift state
       (ISO C99, Annex J.2, point 146).
     */
    +e972   /* unusual character in char/string literal */
    +elib(972)
    -append(972, [MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 21.6 and Rule 21.10. */

    /* Precision has unexpected conversion specifier when calling
       formatted output function
       (ISO C99, Annex J.2, point 147).
     */
    +e2405   /* field width/precision with conversion specifier is undefined */
    +elib(2405)
    -append(2405, [MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 21.6. */

    /* Conversion specification for formatted output function uses
       * to denote argument-supplied field width/precision, but
       corresponding argument not provided
       (ISO C99, Annex J.2, point 148).
     */
    +e2402   /* specified field missing matching int argument */
    +elib(2402)
    -append(2402, [MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 21.6. */

    /* Conversion specification for formatted output function uses
       # or 0 with inappropriate conversion specifier
       (ISO C, Appendix A.6.2, point 82)
       (ISO C90, Annex G.2, point 83)
       (ISO C, Appendix A.6.2, point 83)
       (ISO C90, Annex G.2, point 84)
       (ISO C99, Annex J.2, point 149).
       See Rule 21.6.
     */

    /* Conversion specification for formatted IO function uses length
       modifier with inappropriate conversion specifier
       (ISO C, Appendix A.6.2, point 81)
       (ISO C90, Annex G.2, point 82)
       (ISO C, Appendix A.6.2, point 86)
       (ISO C90, Annex G.2, point 87)
       (ISO C99, Annex J.2, point 150).
     */
    +e566   /* inconsistent/redundant length modifier/flag used w/ conversion specifier */
    +elib(566)
    -append(566, [MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 21.6. */

    /* s conversion specifier encountered by formatted output function,
       argument missing null terminator
       (ISO C99, Annex J.2, point 151).
       See Rule 21.6.
     */

    /* n conversion specification for formatted IO function includes any
       flags, assignment-suppressing character, field width, or precision
       (ISO C99, Annex J.2, point 152).
     */
    +e566   /* inconsistent/redundant length modifier/flag used w/ conversion specifier */
    +elib(566)
    -append(566,[MISRA C:2023 Rule 1.3, required])
    +e2405   /* field width/precision with conversion specifier is undefined */
    +elib(2405)
    -append(2405,[MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 21.6 */

    /* A %% conversion specification for the fprintf or fscanf
       function contains characters between the pair of % characters
       (ISO C, Appendix A.6.2, point 80)
       (ISO C90, Annex G.2, point 81)
       (ISO C99, Annex J.2, point 153).
     */
    +e557   /* invalid conversion specifier */
    +elib(557)
    -append(557,[MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 21.6 */

    /* Invalid conversion specification found in format for formatted IO
       function, strftime, or wcsftime
       (ISO C, Appendix A.6.2, point 79, point 96)
       (ISO C90, Annex G.2, point 80, point 97)
       (ISO C99, Annex J.2, point 154).
     */
    +e557   /* invalid conversion specifier */
    +elib(557)
    -append(557,[MISRA C:2023 Rule 1.3, required])
    +e816   /* non-ISO format specification */
    +elib(816)
    -append(816,[MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 21.6 and Rule 21.10. */

    /* Number of characters transmitted by formatted output function
       greater than INT_MAX
       (ISO C, Appendix A.6.2, point 85)
       (ISO C90, Annex G.2, point 86)
       (ISO C99, Annex J.2, point 155).
       See Rule 21.6.
     */

    /* Result of conversion by formatted input function cannot be
       represented in corresponding object, or receiving object does
       not have appropriate type
       (ISO C, Appendix A.6.2, point 88)
       (ISO C90, Annex G.2, point 89)
       (ISO C99, Annex J.2, point 156)
     */
    +e705   /* format specifies type inconsistent with argument */
    +elib(705)
    -append(705,[MISRA C:2023 Rule 1.3, required])
    +e706   /* format specifies type whose pointee is inconsistent with argument */
    +elib(706)
    -append(706,[MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 21.6. */

    /* c, s, or [ conversion specifier encountered by formatted input
       function, array pointed to by corresponding argument not large
       enough to accept input sequence
       (ISO C99, Annex J.2, point 157).
     */
    +e498   /* unbounded scanf conversion specifier may result in buffer overflow */
    +elib(498)
    -append(498,[MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 21.6. */

    /* c, s, or [ conversion specifier with l qualifier encountered by
       formatted input function, but input is not valid multibyte character
       sequence beginning in initial shift state
       (ISO C99, Annex J.2, point 158).
       See Rule 21.6.
     */

    /* Input item for %p conversion by formatted input function not value
       converted earlier during execution
       (ISO C, Appendix A.6.2, point 87)
       (ISO C90, Annex G.2, point 88)
       (ISO C99, Annex J.2, point 159).
       See Rule 21.6.
     */

    /* v prefixed IO function called with improperly initialized va_list
       argument, or argument is used after function returns
       (ISO C99, Annex J.2, point 160).
       See Rule 21.6.
     */

    /* Contents of array supplied to fgets, gets, or fgetws used after read
       error occurred
       (ISO C99, Annex J.2, point 161).
       See Rule 21.6.
     */

    /* File position indicator for binary stream used after call to ungetc
       where its value was zero before call
       (ISO C99, Annex J.2, point 162).
       See Rule 21.6.
     */

    /* File position indicator for stream used after error occurred during
       call to fread or fwrite
       (ISO C99, Annex J.2, point 163).
       See Rule 21.6.
     */

    /* Use of partial element read by call to fread function
       (ISO C99, Annex J.2, point 164).
       See Rule 21.6.
     */

    /* fseek called for text stream with nonzero offset; offset not returned
       by previous call to ftell for same stream, or whence is not SEEK_SET
       (ISO C99, Annex J.2, point 165).
       See Rule 21.6.
     */

    /* fsetpos called to set position not returned by previous call to fgetpos
       function on same stream
       (ISO C99, Annex J.2, point 166).
       See Rule 21.6.
     */

    /* Non-null pointer returned by call calloc, malloc, or realloc with zero
       requested size used to access object
       (ISO C99, Annex J.2, point 167).
       See Rule 21.3.
     */

    /* Referring to deallocated space
       (ISO C, Appendix A.6.2, point 90)
       (ISO C90, Annex G.2, point 91)
       (ISO C99, Annex J.2, point 168).
     */
    +e449   /* memory likely deallocated */
    +elib(449)
    -append(449,[MISRA C:2023 Rule 1.3, required])
    +e2434   /* memory potentially deallocated */
    +elib(2434)
    -append(2434,[MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 21.3. */

    /* Misuse of free or realloc
       (ISO C, Appendix A.6.2, point 91)
       (ISO C90, Annex G.2, point 92)
       (ISO C99, Annex J.2, point 169).
       See Rule 21.3 and Rule 22.2
     */

    /* Value of object allocated by malloc used
       (ISO C99, Annex J.2, point 170).
       See Rule 21.3.
     */

    /* Value of any bytes in new object allocated by realloc beyond size of old
       object used
       (ISO C99, Annex J.2, point 171).
       See Rule 21.3.
     */

    /* Program executes more than one call to exit
       (ISO C, Appendix A.6.2, point 92)
       (ISO C90, Annex G.2, point 93)
       (ISO C99, Annex J.2, point 172).
       See Rule 21.8.
     */

    /* During call to function registered with atexit, call is made to longjmp
       that would terminate call to registered function
       (ISO C99, Annex J.2, point 173).
       See Rule 21.4.
     */

    /* During call to function registered with the atexit function, call is
       made to longjmp that would terminate the call to registered function
       (ISO C99, Annex J.2, point 174).
       See Rule 21.19.
     */

    /* Command executed through system function in manner documented as causing
       UB
       (ISO C99, Annex J.2, point 175).
       See Rule 21.8.
     */

    /* Searching or sorting utility function called with invalid pointer argument
       (ISO C99, Annex J.2, point 176).
       See Rule 21.9.
     */

    /* Comparison function called by searching or sorting utility function alters
       array, or returns ordering values inconsistently
       (ISO C99, Annex J.2, point 177).
       See Rule 21.9.
     */

    /* Array searched by bsearch does not have elements in proper order
       (ISO C99, Annex J.2, point 178).
       See Rule 21.9.
     */

    /* An array written to by a copying or concatenation function is
       too small
       (ISO C, Appendix A.6.2, point 95)
       (ISO C90, Annex G.2, point 96)
       (ISO C99, Annex J.2, point 180).
     */
    +e419   /* data overrun */
    +elib(419)
    -append(419,[MISRA C:2023 Rule 1.3, required])

    /* String utility function called with invalid pointer argument
       (ISO C99, Annex J.2, point 181).
       See Dir 4.11.
     */

    /* Contents of array used after call to strxfrm, strftime, wcsxfrm, or wcsftime
       in which length was too small to hold entire result
       (ISO C99, Annex J.2, point 182).
       See Rule 21.10 (Does not support wcsxfrm).
     */

    /* First argument in first call to strtok or wcstok is nullptr
       (ISO C99, Annex J.2, point 183).
       See Dir 4.11.
     */

    /* Type of argument to type-generic macro not compatible with type of
       corresponding parameter of selected function
       (ISO C99, Annex J.2, point 184).
     */
    +e2504   /* operand argument to type-generic macro has inappropriate type */
    +elib(2504)
    -append(2504,[MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 21.11. */

    /* Complex argument supplied for generic parameter of type-generic macro has no
       corresponding complex function
       (ISO C99, Annex J.2, point 185).
     */
    +e2504   /* operand argument to type-generic macro has inappropriate type */
    +elib(2504)
    -append(2504,[MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 21.11. */


    /* Argument for s specifier without l qualifier in call to fwprintf does not
       point to valid multibyte character sequence beginning in initial shift state
       (ISO C99, Annex J.2, point 186).
       See Rule 21.6.
     */

    /* In call to wcstok, object pointed to does not have value stored by previous
       call for same wide string
       (ISO C99, Annex J.2, point 187).
       See Dir 4.11.
     */

    /* Value of argument of type wint_t to wide character classification or case
       mapping function neither equal to WEOF nor representable as wchar_t
       (ISO C99, Annex J.2, point 189).
       See Dir 4.11.
     */

    /* Order of evaluation
       (ISO C, Appendix A.6.1, point 7)
       (ISO C90, Annex G.1, point 7)
       (ISO C99, Annex J.1, point 15).
       See Rule 13.2
     */

    /* Side effects order
       (ISO C, Appendix A.6.1, point 8)
       (ISO C90, Annex G.1, point 8)
       (ISO C99, Annex J.1, point 15).
     */
    +e931   /* both sides of an expression have side-effects */
    +elib(931)
    -append(931,[MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 13.2 */

    /* Function argument evaluation
       (ISO C, Appendix A.6.1, point 9)
       (ISO C90, Annex G.1, point 9)
       (ISO C99, Annex J.1, point 16).
       See Rule 13.2
     */

    /* The order in which # and ## operations are evaluated during
       macro substitution
       (ISO C, Appendix A.6.1, point 12)
       (ISO C90, Annex G.1, point 12)
       (ISO C99, Annex J.1, point 25).
     */
    +e9023   /* multiple '#/##' operators in macro definition */
    +elib(9023)
    -append(9023,[MISRA C:2023 Rule 1.3, required])
    /* Also, see Rule 20.10 and Rule 20.11 */

/**** Rule 1.4 (Req) ************/

    +e586        /* to activate the deprecation message */
    +elib(586)

    /* C11 Keywords */
    -deprecate(keyword,_Alignas)
    -append(586(_Alignas),[MISRA C:2023 Rule 1.4, required])
    -deprecate(keyword,_Alignof)
    -append(586(_Alignof),[MISRA C:2023 Rule 1.4, required])
    -deprecate(keyword,_Noreturn)
    -append(586(_Noreturn),[MISRA C:2023 Rule 1.4, required])

    /* Facilities of Annex K (Bounds-checking interfaces) */
    -deprecate(type,errno_t)
    -append(586(errno_t),[MISRA C:2023 Rule 1.4, required])
    -deprecate(type,rsize_t)
    -append(586(rsize_t),[MISRA C:2023 Rule 1.4, required])
    -deprecate(type,constraint_handler_t)
    -append(586(constraint_handler_t),[MISRA C:2023 Rule 1.4, required])

    -deprecate(macro,RSIZE_MAX)
    -append(586(RSIZE_MAX),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,L_tmpnam_s)
    -append(586(L_tmpnam_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,TMP_MAX_S)
    -append(586(TMP_MAX_S),[MISRA C:2023 Rule 1.4, required])

    -deprecate(function,abort_handler_s)
    -append(586(abort_handler_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,asctime_s)
    -append(586(asctime_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,bsearch_s)
    -append(586(bsearch_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,ctime_s)
    -append(586(ctime_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,fopen_s)
    -append(586(fopen_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,fprintf_s)
    -append(586(fprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,freopen_s)
    -append(586(freopen_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,fscanf_s)
    -append(586(fscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,fwprintf_s)
    -append(586(fwprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,fwscanf_s)
    -append(586(fwscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,getenv_s)
    -append(586(getenv_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,gets_s)
    -append(586(gets_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,gmtime_s)
    -append(586(gmtime_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,ignore_handler_s)
    -append(586(ignore_handler_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,localtime_s)
    -append(586(localtime_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,mbsrtowcs_s)
    -append(586(mbsrtowcs_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,mbstowcs_s)
    -append(586(mbstowcs_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,memcpy_s)
    -append(586(memcpy_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,memmove_s)
    -append(586(memmove_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,memset_s)
    -append(586(memset_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,printf_s)
    -append(586(printf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,qsort_s)
    -append(586(qsort_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,scanf_s)
    -append(586(scanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,set_constraint_handler_s)
    -append(586(set_constraint_handler_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,snprintf_s)
    -append(586(snprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,snwprintf_s)
    -append(586(snwprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,sprintf_s)
    -append(586(sprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,sscanf_s)
    -append(586(sscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,strcat_s)
    -append(586(strcat_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,strcpy_s)
    -append(586(strcpy_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,strerror_s)
    -append(586(strerror_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,strerrorlen_s)
    -append(586(strerrorlen_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,strncat_s)
    -append(586(strncat_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,strncpy_s)
    -append(586(strncpy_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,strnlen_s)
    -append(586(strnlen_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,strtok_s)
    -append(586(strtok_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,swprintf_s)
    -append(586(swprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,swscanf_s)
    -append(586(swscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,tmpfile_s)
    -append(586(tmpfile_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,tmpnam_s)
    -append(586(tmpnam_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,vfprintf_s)
    -append(586(vfprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,vfscanf_s)
    -append(586(vfscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,vfwprintf_s)
    -append(586(vfwprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,vfwscanf_s)
    -append(586(vfwscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,vprintf_s)
    -append(586(vprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,vscanf_s)
    -append(586(vscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,vsnprintf_s)
    -append(586(vsnprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,vsnwprintf_s)
    -append(586(vsnwprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,vsprintf_s)
    -append(586(vsprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,vsscanf_s)
    -append(586(vsscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,vswprintf_s)
    -append(586(vswprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,vswscanf_s)
    -append(586(vswscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,vwprintf_s)
    -append(586(vwprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,vwscanf_s)
    -append(586(vwscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,wcrtomb_s)
    -append(586(wcrtomb_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,wcscat_s)
    -append(586(wcscat_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,wcscpy_s)
    -append(586(wcscpy_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,wcsncat_s)
    -append(586(wcsncat_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,wcsncpy_s)
    -append(586(wcsncpy_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,wcsnlen_s)
    -append(586(wcsnlen_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,wcsrtombs_s)
    -append(586(wcsrtombs_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,wcstok_s)
    -append(586(wcstok_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,wcstombs_s)
    -append(586(wcstombs_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,wctomb_s)
    -append(586(wctomb_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,wmemcpy_s)
    -append(586(wmemcpy_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,wmemmove_s)
    -append(586(wmemmove_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,wprintf_s)
    -append(586(wprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(function,wscanf_s)
    -append(586(wscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,abort_handler_s)
    -append(586(abort_handler_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,asctime_s)
    -append(586(asctime_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,bsearch_s)
    -append(586(bsearch_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,ctime_s)
    -append(586(ctime_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,fopen_s)
    -append(586(fopen_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,fprintf_s)
    -append(586(fprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,freopen_s)
    -append(586(freopen_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,fscanf_s)
    -append(586(fscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,fwprintf_s)
    -append(586(fwprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,fwscanf_s)
    -append(586(fwscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,getenv_s)
    -append(586(getenv_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,gets_s)
    -append(586(gets_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,gmtime_s)
    -append(586(gmtime_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,ignore_handler_s)
    -append(586(ignore_handler_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,localtime_s)
    -append(586(localtime_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,mbsrtowcs_s)
    -append(586(mbsrtowcs_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,mbstowcs_s)
    -append(586(mbstowcs_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,memcpy_s)
    -append(586(memcpy_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,memmove_s)
    -append(586(memmove_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,memset_s)
    -append(586(memset_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,printf_s)
    -append(586(printf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,qsort_s)
    -append(586(qsort_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,scanf_s)
    -append(586(scanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,set_constraint_handler_s)
    -append(586(set_constraint_handler_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,snprintf_s)
    -append(586(snprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,snwprintf_s)
    -append(586(snwprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,sprintf_s)
    -append(586(sprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,sscanf_s)
    -append(586(sscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,strcat_s)
    -append(586(strcat_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,strcpy_s)
    -append(586(strcpy_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,strerror_s)
    -append(586(strerror_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,strerrorlen_s)
    -append(586(strerrorlen_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,strncat_s)
    -append(586(strncat_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,strncpy_s)
    -append(586(strncpy_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,strnlen_s)
    -append(586(strnlen_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,strtok_s)
    -append(586(strtok_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,swprintf_s)
    -append(586(swprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,swscanf_s)
    -append(586(swscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,tmpfile_s)
    -append(586(tmpfile_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,tmpnam_s)
    -append(586(tmpnam_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,vfprintf_s)
    -append(586(vfprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,vfscanf_s)
    -append(586(vfscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,vfwprintf_s)
    -append(586(vfwprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,vfwscanf_s)
    -append(586(vfwscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,vprintf_s)
    -append(586(vprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,vscanf_s)
    -append(586(vscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,vsnprintf_s)
    -append(586(vsnprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,vsnwprintf_s)
    -append(586(vsnwprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,vsprintf_s)
    -append(586(vsprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,vsscanf_s)
    -append(586(vsscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,vswprintf_s)
    -append(586(vswprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,vswscanf_s)
    -append(586(vswscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,vwprintf_s)
    -append(586(vwprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,vwscanf_s)
    -append(586(vwscanf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,wcrtomb_s)
    -append(586(wcrtomb_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,wcscat_s)
    -append(586(wcscat_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,wcscpy_s)
    -append(586(wcscpy_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,wcsncat_s)
    -append(586(wcsncat_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,wcsncpy_s)
    -append(586(wcsncpy_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,wcsnlen_s)
    -append(586(wcsnlen_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,wcsrtombs_s)
    -append(586(wcsrtombs_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,wcstok_s)
    -append(586(wcstok_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,wcstombs_s)
    -append(586(wcstombs_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,wctomb_s)
    -append(586(wctomb_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,wmemcpy_s)
    -append(586(wmemcpy_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,wmemmove_s)
    -append(586(wmemmove_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,wprintf_s)
    -append(586(wprintf_s),[MISRA C:2023 Rule 1.4, required])
    -deprecate(macro,wscanf_s)
    -append(586(wscanf_s),[MISRA C:2023 Rule 1.4, required])

/**** Rule 1.5 (Req) ************/

    /* Not currently supported */

/**** Rule 2.1 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e527       /* unreachable */
    +elib(527)
    -append(527,[MISRA C:2023 Rule 2.1, required])
    +e681       /* loop not entered */
    +elib(681)
    -append(681,[MISRA C:2023 Rule 2.1, required])
    +e827       /* loop not reachable */
    +elib(827)
    -append(827,[MISRA C:2023 Rule 2.1, required])

/**** Rule 2.2 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e438       /* value not used */
    +elib(438)
    -append(438,[MISRA C:2023 Rule 2.2, required])
    +e505       /* redundant argument to comma */
    +elib(505)
    -append(505,[MISRA C:2023 Rule 2.2, required])
    +e520       /* highest operator has no side effects */
    +elib(520)
    -append(520,[MISRA C:2023 Rule 2.2, required])
    +e521       /* highest operator has no side effects */
    +elib(521)
    -append(521,[MISRA C:2023 Rule 2.2, required])
    +e522       /* highest operator has no side effects */
    +elib(522)
    -append(522,[MISRA C:2023 Rule 2.2, required])
    +e774       /* condition always evaluates to true/false */
    +elib(774)
    -append(774,[MISRA C:2023 Rule 2.2, required])

/**** Rule 2.3 (Adv) ************/

    +e751	   /* local typedef not referenced */
    +elib(751)
    -append(751,[MISRA C:2023 Rule 2.3, advisory])
    +e756	   /* global not referenced */
    +elib(756)
    -append(756,[MISRA C:2023 Rule 2.3, advisory])

/**** Rule 2.4 (Adv) ************/

    +e753	   /* local tag not referenced */
    +elib(753)
    -append(753,[MISRA C:2023 Rule 2.4, advisory])
    +e9058
    +elibsym(9058)
    -append(9058,[MISRA C:2023 Rule 2.4, advisory])

/**** Rule 2.5 (Adv) ************/

    +e750	   /* local macro not referenced */
    +elib(750)
    -append(750,[MISRA C:2023 Rule 2.5, advisory])
    +e755	   /* global macro not referenced */
    +elib(755)
    -append(755,[MISRA C:2023 Rule 2.5, advisory])

/**** Rule 2.6 (Adv) ************/

    +e563	   /* label not referenced */
    +elib(563)
    -append(563,[MISRA C:2023 Rule 2.6, advisory])

/**** Rule 2.7 (Adv) ************/

    +e715      	     /* not referenced */
    +elib(715)
    -append(715,[MISRA C:2023 Rule 2.7, advisory])

/**** Rule 2.8 (Adv) ************/

    +e528     /* static symbol 'symbol' not referenced */
    +elib(528)
    -append(528,[MISRA C:2023 Rule 2.8, advisory])

    +e529     /* local variable 'symbol' declared in 'symbol' not subsequently referenced */
    +elib(529)
    -append(529,[MISRA C:2023 Rule 2.8, advisory])

    +e714     /* external symbol 'symbol' was defined but not referenced */
    +elib(714)
    -append(714,[MISRA C:2023 Rule 2.8, advisory])

    +e754     /* local 'string' member 'symbol' not referenced */
    +elib(754)
    -append(754,[MISRA C:2023 Rule 2.8, advisory])

    +e768     /* global structure member 'symbol' not referenced */
    +elib(768)
    -append(768,[MISRA C:2023 Rule 2.8, advisory])

/**** Rule 3.1 (Req) ************/

    -fnc                   /* flag nested comments */
    +e602                  /* comment within comment */
    +elib(602)
    -append(602,[MISRA C:2023 Rule 3.1, required])
    +e9059
    +elib(9059)
    -append(9059,[MISRA C:2023 Rule 3.1, required])
    +e9066
    +elib(9066)
    -append(9066,[MISRA C:2023 Rule 3.1, required])

/**** Rule 3.2 (Req) ************/

    +e427      	     /* C++ comment ends in \\ */
    +elib(427)
    -append(427,[MISRA C:2023 Rule 3.2, required])

/**** Rule 4.1 (Req) ************/

    +e9039                              /* prohibited escape sequence */
    +elib(9039)
    -append(9039,[MISRA C:2023 Rule 4.1, required])

/**** Rule 4.2 (Adv) ************/

    -ftg                        /* inhibit use of trigraphs */
    +e584                       /* activate trigraph detected message */
    +elib(584)
    -append(584,[MISRA C:2023 Rule 4.2, advisory])
    +e739                       /* activate trigraph in string message */
    +elib(739)
    -append(739,[MISRA C:2023 Rule 4.2, advisory])
    +e9060                       /* trigraph in comment */
    +elib(9060)
    -append(9060,[MISRA C:2023 Rule 4.2, advisory])

/**** Rule 5.1 (Req) ************/

    -idlen(31, x)       /* Sets the number of significant characters in an external
                           identifier, update as appropriate for your target.  Use
                           'X' instead of 'x' if external identifiers are not case
                           sensitive. C90 guarantees 6 characters are significant,
                           C99 guarantees at least 31 characters are significant. */

    +e621                /* identifier clash */
    +elib(621)
    -append(621("external vs external"), [MISRA C:2023 Rule 5.1, required])

/**** Rule 5.2 (Req) ************/

    -idlen(63, c)       /* Sets the number of significant characters in an internal
                           identifier, update as appropriate for your target.  Use
                           'C' instead of 'c' if internal identifiers are not case
                           sensitive. C90 guarantees 31 characters are significant,
                           C99 guarantees at least 63 characters are significant. */

    +e621                /* identifier clash */
    +elib(621)
    -append(621("tag vs tag"), [MISRA C:2023 Rule 5.2, required])
    -append(621("field vs field"), [MISRA C:2023 Rule 5.2, required])
    -append(621("label vs label"), [MISRA C:2023 Rule 5.2, required])
    -append(621("internal vs internal, same scope"), [MISRA C:2023 Rule 5.2, required])
    -append(621("internal vs external, same scope"), [MISRA C:2023 Rule 5.2, required])
    -append(621("external vs internal, same scope"), [MISRA C:2023 Rule 5.2, required])

/**** Rule 5.3 (Req) ************/

    +e578               /* enable reports of name hiding */
    +elib(578)
    -append(578,[MISRA C:2023 Rule 5.3, required])

    /* This rule uses the same -idlen option values as 5.2 */

    +e621                /* identifier clash */
    +elib(621)
    -append(621("internal vs internal, enclosing scope"), [MISRA C:2023 Rule 5.3, required])
    -append(621("internal vs external, enclosing scope"), [MISRA C:2023 Rule 5.3, required])
    -append(621("external vs internal, enclosing scope"), [MISRA C:2023 Rule 5.3, required])

/**** Rule 5.4 (Req) ************/

    -idlen(63, p)       /* Sets the number of significant characters in a preprocessor
                           identifier, update as appropriate for your target.  Use
                           'P' instead of 'p' if preprocessor identifiers are not case
                           sensitive. C90 guarantees 31 characters are significant,
                           C99 guarantees at least 63 characters are significant. */

    +e547               /* conflicting macro definition */
    +elib(547)
    -append(547,[MISRA C:2023 Rule 5.4, required])

    +e767               /* macro defined differently in another module */
    +elib(767)
    -append(767,[MISRA C:2023 Rule 5.4, required])

    +e760               /* macro redefined identically */
    +elib(760)
    -append(760,[MISRA C:2023 Rule 5.4, required])

    +e962               /* macro defined identically in another module */
    +elib(962)
    -append(962,[MISRA C:2023 Rule 5.4, required])

    +e621               /* identifier clash */
    +elib(621)
    -append(621("macro vs macro"), [MISRA C:2023 Rule 5.4, required])
    -append(621("macro vs macro parameter"), [MISRA C:2023 Rule 5.4, required])
    -append(621("macro parameter vs macro parameter"), [MISRA C:2023 Rule 5.4, required])

/**** Rule 5.5 (Req) ************/

    /* 9095 - symbol has same name as previously defined macro */
    +e9095
    +elib(9095)
    -append(9095,[MISRA C:2023 Rule 5.5, required])

    /* 9096 - symbol has same name as subsequently defined macro */
    +e9096
    +elib(9096)
    -append(9096,[MISRA C:2023 Rule 5.5, required])

/**** Rule 5.6 (Req) ************/

    /* Not currently supported */

/**** Rule 5.7 (Req) ************/

    +e407               /* Inconsistent use of tag */
    +elib(407)
    -append(407,[MISRA C:2023 Rule 5.7, required])

    +e631               /* Tag defined differently */
    +elib(631)
    -append(631,[MISRA C:2023 Rule 5.7, required])

/**** Rule 5.8 (Req) ************/

    /* Not currently supported */

/**** Rule 5.9 (Adv) ************/

    /* Not currently supported */

/**** Rule 6.1 (Req) ************/

    /* 9149     bit field must be explicitly signed integer, unsigned integer,
                or bool */
    +e9149
    +elib(9149)
    -append(9149,[MISRA C:2023 Rule 6.1, required])

/**** Rule 6.2 (Req) ************/

    +e9088               /* named signed single-bit bit-field */
    +elib(9088)
    -append(9088,[MISRA C:2023 Rule 6.2, required])

/**** Rule 6.3 (Req) ************/

    +e9202       /* bitfield declared as member of union */
    +elib(9202)
    -append(9202,[MISRA C:2023 Rule 6.3, required])

/**** Rule 7.1 (Req) ************/

    +e9001                              /* Octal constant used */
    +elib(9001)
    -append(9001,[MISRA C:2023 Rule 7.1, required])

/**** Rule 7.2 (Req) ************/

    +e9048                              /* unsigned literal without 'U' suffix */
    +elib(9048)
    -append(9048,[MISRA C:2023 Rule 7.2, required])

/**** Rule 7.3 (Req) ************/

    +e620                           /* suspicious constant */
    +elib(620)
    -append(620,[MISRA C:2023 Rule 7.3, required])
    +e9057                          /* "l" after "u" in literal suffix */
    +elib(9057)
    -append(9057,[MISRA C:2023 Rule 7.3, required])

/**** Rule 7.4 (Req) ************/

    +fsc
    +e489                           /* attempting to modify a string literal */
    +elib(489)
    -append(489,[MISRA C:2023 Rule 7.4, required])
    +e2776                          /* string literal not converted to const qualified type */
    +elib(2776)
    -append(2776,[MISRA C:2023 Rule 7.4, required])
    +e1778                          /* assignment of string literal not const safe */
    +elib(1778)
    -append(1778,[MISRA C:2023 Rule 7.4, required])

/**** Rule 7.5 (Mand) ************/

    +e2505       /* argument to integer constant macro should be an unsuffixed integer literal */
    +elib(2505)
    -append(2505,[MISRA C:2023 Rule 7.5, mandatory])

/**** Rule 7.6 (Req) ************/

    +e9222 /* small integer variant of a minimum-width integer constant macro is used */
    +elib(9222)
    -append(9222, [MISRA C:2023 Rule 7.6, required])

/**** Rule 8.1 (Req) ************/

    +e601                           /* no explicit type */
    +elib(601)
    -append(601,[MISRA C:2023 Rule 8.1, required])
    +e808                           /* no explicit type */
    +elib(808)
    -append(808,[MISRA C:2023 Rule 8.1, required])
    +e832                           /* parameter has no explicit type */
    +elib(832)
    -append(832,[MISRA C:2023 Rule 8.1, required])

/**** Rule 8.2 (Req) ************/

    +e937                     /* old-style function declaration */
    +elib(937)
    -append(937,[MISRA C:2023 Rule 8.2, required])
    +e18                          /* symbol redeclared */
    +elib(18)
    -append(18,[MISRA C:2023 Rule 8.2, required])

    +e936                         /* old-style function definition */
    +elib(936)
    -append(936,[MISRA C:2023 Rule 8.2, required])

    +e955                         /* param name missing from prototype */
    +elib(955)
    -append(955,[MISRA C:2023 Rule 8.2, required])

/**** Rule 8.3 (Req) ************/

    +e18                          /* symbol redeclared */
    +elib(18)
    -append(18,[MISRA C:2023 Rule 8.3, required])

    /* 9072 parameter has different name than previous declaration  */
    +e9072
    +elib(9072)
    -append(9072,[MISRA C:2023 Rule 8.3, required])

    /* 9073 parameter has type alias name type difference with previous
            declaration */
    +e9073
    +elib(9073)
    -append(9073,[MISRA C:2023 Rule 8.3, required])

    /* 9094 return type has type alias name difference with previous
            declaration */
    +e9094
    +elib(9094)
    -append(9094,[MISRA C:2023 Rule 8.3, required])

/**** Rule 8.4 (Req) ************/

    +e15        /* symbol redeclared */
    +elib(15)
    -append(15,[MISRA C:2023 Rule 8.4, required])

    /* 957 - function defined without prototype in scope */
    +e957
    +elib(957)
    -append(957,[MISRA C:2023 Rule 8.4, required])

    /* 9075 external symbol defined without a prior declaration */
    +e9075
    +elib(9075)
    -append(9075,[MISRA C:2023 Rule 8.4, required])

/**** Rule 8.5 (Req) ************/

    +e9004        /* object/function previously declared */
    +elib(9004)
    -append(9004,[MISRA C:2023 Rule 8.5, required])

/**** Rule 8.6 (Req) ************/

    +e2467       /* multiple definitions of function */
    +elib(2467)
    -append(2467,[MISRA C:2023 Rule 8.6, required])

    +e2469       /* multiple definitions of variable */
    +elib(2469)
    -append(2469,[MISRA C:2023 Rule 8.6, required])

/**** Rule 8.7 (Adv) ************/

    +e765        /* could be made static */
    +elib(765)
    -append(765,[MISRA C:2023 Rule 8.7, advisory])

/**** Rule 8.8 (Req) ************/

    +e839           /* storage class assumed static */
    +elib(839)
    -append(839,[MISRA C:2023 Rule 8.8, required])

/**** Rule 8.9 (Adv) ************/

    +e9003        /* could define variable at block scope */
    +elib(9003)
    -append(9003,[MISRA C:2023 Rule 8.9, advisory])

/**** Rule 8.10 (Req) ************/

    +e695    	     /* inline function without storage-class specifier */
    +elib(695)
    -append(695,[MISRA C:2023 Rule 8.10, required])
    +estring(9056,extern)     /* inline function defined with extern */
    -append(9056,[MISRA C:2023 Rule 8.10, required])

/**** Rule 8.11 (Adv) ************/

    +e9067             /* array has no dimension or initializer */
    +elib(9067)
    -append(9067,[MISRA C:2023 Rule 8.11, advisory])

/**** Rule 8.12 (Req) ************/

    +e488	/* duplicate enumerator values */
    +elib(488)
    -append(488,[MISRA C:2023 Rule 8.12, required])

/**** Rule 8.13 (Adv) ************/

    /* Enable "could be made const" messages for unreferenced variables */
    +fuv

    /* Report parameters even if exclusively cast to void */
    -fcv

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e818	/* pointer could be declared pointing to const */
    +elib(818)
    -append(818,[MISRA C:2023 Rule 8.13, advisory])
    +e844	/* pointer could be declared pointing to const */
    +elib(844)
    -append(844,[MISRA C:2023 Rule 8.13, advisory])
    +e954	/* pointer could be declared pointing to const */
    +elib(954)
    -append(954,[MISRA C:2023 Rule 8.13, advisory])

/**** Rule 8.14 (Req) ************/

    +e586       /* Symbol is deprecated */
    +elib(586)
    -deprecate(keyword,restrict)
    -append(586(restrict),[MISRA C:2023 Rule 8.14, required])

/**** Rule 8.15 (Req) ************/

    +e2502       /* differing alignment requirements seen */
    +elib(2502)
    -append(2502,[MISRA C:2023 Rule 8.15, required])

    +e9503       /* equivalent alignment derived differently */
    +elib(9503)
    -append(9503,[MISRA C:2023 Rule 8.15, required])

/**** Rule 8.16 (Adv) ************/

    +e9203       /* declaration contains an alignment attribute whose expression evaluates to zero */
    +elib(9203)
    -append(9203,[MISRA C:2023 Rule 8.16, advisory])

/**** Rule 8.17 (Adv) ************/

    +e9205       /* declaration contains multiple alignment attributes */
    +elib(9205)
    -append(9205,[MISRA C:2023 Rule 8.17, advisory])

/**** Rule 9.1 (Mand) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e644                   /* Symbol may not have been initialized */
    +elib(644)
    -append(644,[MISRA C:2023 Rule 9.1, mandatory])
    +e530                   /* Symbol not initialized */
    +elib(530)
    -append(530,[MISRA C:2023 Rule 9.1, mandatory])

    /* 603 - argument to parameter of type pointer to const may be a pointer to
        uninitialized memory */
    +e603
    +elib(603)
    -append(603,[MISRA C:2023 Rule 9.1, mandatory])

/**** Rule 9.2 (Req) ************/

    +e9069                  /* aggregate initialize needs braces or designator */
    +elib(9069)
    -append(9069,[MISRA C:2023 Rule 9.2, required])

/**** Rule 9.3 (Req) ************/

    +e9068                  /* too few initializers */
    +elib(9068)
    -append(9068,[MISRA C:2023 Rule 9.3, required])

/**** Rule 9.4 (Req) ************/

    +e485                               /* duplicate initialization */
    +elib(485)
    -append(485,[MISRA C:2023 Rule 9.4, required])

/**** Rule 9.5 (Req) ************/

    +e9054                              /* designated initializer and dimensionless array */
    +elib(9054)
    -append(9054,[MISRA C:2023 Rule 9.5, required])

/**** Rule 9.6 (Req) ************/

    +e2903 /* initializer list has a chained designator and at least one other field without a designator */
    +elib(2903)
    -append(2903, [MISRA C:2023 Rule 9.6, required])

    +e2904 /* a sub-object was initialized using a braced, positional init list and at least one chained designator */
    +elib(2904)
    -append(2904, [MISRA C:2023 Rule 9.6, required])

/**** Rule 9.7 (Mand) ************/

    /* Not currently supported */

/**** Rule 10.1 (Req) ************/

    +e48				/* bad type */
    +elib(48)
    -append(48,[MISRA C:2023 Rule 10.1, required])

    +e9027                              /* unpermitted operand */
    +elib(9027)
    -append(9027,[MISRA C:2023 Rule 10.1, required])

    +e9099                              /* pointer operand with logical operator */
    +elib(9099)
    -append(9099,[MISRA C:2023 Rule 10.1, required])

/**** Rule 10.2 (Req) ************/

    +e9028                              /* unpermitted arithmetic */
    +elib(9028)
    -append(9028,[MISRA C:2023 Rule 10.2, required])

/**** Rule 10.3 (Req) ************/

    +e9034                              /* expression assigned to narrower or different essential type */
    +elib(9034)
    -append(9034,[MISRA C:2023 Rule 10.3, required])

/**** Rule 10.4 (Req) ************/

    +e9029                              /* mismatched essential type */
    +elib(9029)
    -append(9029,[MISRA C:2023 Rule 10.4, required])

/**** Rule 10.5 (Adv) ************/

    +e9030                              /* impermissible cast */
    +elib(9030)
    -append(9030,[MISRA C:2023 Rule 10.5, advisory])

/**** Rule 10.6 (Req) ************/

    +e9031                              /* composite expression assigned to wider essential type */
    +elib(9031)
    -append(9031,[MISRA C:2023 Rule 10.6, required])

/**** Rule 10.7 (Req) ************/

    +e9032                              /* composite expression with smaller essential type than other operand*/
    +elib(9032)
    -append(9032,[MISRA C:2023 Rule 10.7, required])

/**** Rule 10.8 (Req) ************/

    +e9033                              /* impermissible cast of composite expression */
    +elib(9033)
    -append(9033,[MISRA C:2023 Rule 10.8, required])

/**** Rule 11.1 (Req) ************/

    /* 176 - cannot cast non-pointer non-integer to function pointer */
    +e176
    +elib(176)
    -append(176,[MISRA C:2023 Rule 11.1, required])

    /* 178 - cannot cast function pointer to non-pointer non-integer */
    +e178
    +elib(178)
    -append(178,[MISRA C:2023 Rule 11.1, required])

    +e9074                   /* conversion between a pointer to function and another type */
    +elib(9074)
    -append(9074,[MISRA C:2023 Rule 11.1, required])

/**** Rule 11.2 (Req) ************/

    +e9076                   /* conversion between a pointer to incomplete type and another type */
    +elib(9076)
    -append(9076,[MISRA C:2023 Rule 11.2, required])

/**** Rule 11.3 (Req) ************/

    +e9087         /* cast from pointer to pointer */
    +elib(9087)
    -append(9087,[MISRA C:2023 Rule 11.3, required])

/**** Rule 11.4 (Adv) ************/

    +e9078                        /* cast pointer/integer */
    +elib(9078)
    -append(9078,[MISRA C:2023 Rule 11.4, advisory])

/**** Rule 11.5 (Adv) ************/

    +e9079         /* cast from pointer to pointer */
    +elib(9079)
    -append(9079,[MISRA C:2023 Rule 11.5, advisory])

/**** Rule 11.6 (Req) ************/

    +elib(177)     /* operand cannot be cast to object pointer type */
    +etype(177, "void `*")
    -append(177,[MISRA C:2023 Rule 11.6, required])

    +elib(179)     /* object pointer cannot be cast to type */
    +etype(179, "void `*")
    -append(179,[MISRA C:2023 Rule 11.6, required])

    +elib(923)     /* cast pointer/non-pointer */
    +etype(923, "void `*")
    -append(923,[MISRA C:2023 Rule 11.6, required])

/**** Rule 11.7 (Req) ************/

    +e177       /* type cannot be cast to object pointer */
    +elib(177)
    -append(177,[MISRA C:2023 Rule 11.7, required])

    +e179       /* object pointer cannot be cast to type */
    +elib(179)
    -append(179,[MISRA C:2023 Rule 11.7, required])

    +e9295      /* cast between object pointer and forbidden essential type */
    +elib(9295)
    -append(9295,[MISRA C:2023 Rule 11.7, required])

/**** Rule 11.8 (Req) ************/

    +e9005                              /* attempt to cast away const/volatile from pointer or reference */
    +elib(9005)
    -append(9005,[MISRA C:2023 Rule 11.8, required])

/**** Rule 11.9 (Req) ************/

    +e9080      /* integer null pointer constant */
    +elib(9080)
    -append(9080,[MISRA C:2023 Rule 11.9, required])

/**** Rule 11.10 (Req) ************/

    +e4175     /* _Atomic cannot be applied to incomplete type 'void'  */
    +elib(4175)
    -append(4175,[MISRA C:2023 Rule 11.10, required])

/**** Rule 12.1 (Adv) ************/

    +e9050        /* dependence placed on precedence */
    +elib(9050)
    -append(9050,[MISRA C:2023 Rule 12.1, advisory])

    +e9097        /* unparenthesized argument to sizeof */
    +elib(9097)
    -append(9097,[MISRA C:2023 Rule 12.1, advisory])

/**** Rule 12.2 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e9053          /* shift value is negative, equal to, or greater than size of LHS */
    +elib(9053)
    -append(9053,[MISRA C:2023 Rule 12.2, required])

/**** Rule 12.3 (Adv) ************/

    +e9008                              /* comma operator used */
    +elib(9008)
    -append(9008,[MISRA C:2023 Rule 12.3, advisory])

/**** Rule 12.4 (Adv) ************/

    +e2421  /* evaluation of constant expression results in unsigned wrap-around */
    +elib(2421)
    -append(2421,[MISRA C:2023 Rule 12.4, advisory])

/**** Rule 12.5 (Mand) ************/

    +e682               /* sizeof applied to parameter whose type is sized array */
    +elib(682)
    -append(682,[MISRA C:2023 Rule 12.5, mandatory])

    +e882               /* sizeof applied to parameter declared as incomplete array */
    +elib(882)
    -append(882,[MISRA C:2023 Rule 12.5, mandatory])

/**** Rule 12.6 (Req) ************/

    +e181     /* direct access of atomic record type */
    +elib(181)
    -append(181,[MISRA C:2023 Rule 12.6, required])

/**** Rule 13.1 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e446                              /* side effect in initializer */
    +elib(446)
    -append(446,[MISRA C:2023 Rule 13.1, required])

/**** Rule 13.2 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e564			/* variable depends on order of evaluation */
    +elib(564)
    -append(564,[MISRA C:2023 Rule 13.2, required])

/**** Rule 13.3 (Adv) ************/

    +e9049                              /* increment/decrement combined with other operations */
    +elib(9049)
    -append(9049,[MISRA C:2023 Rule 13.3, advisory])

/**** Rule 13.4 (Adv) ************/

    +e720                    /* Boolean test of assignment */
    +elib(720)
    -append(720,[MISRA C:2023 Rule 13.4, advisory])
    +e820                    /* Boolean test of parenthesized assignment */
    +elib(820)
    -append(820,[MISRA C:2023 Rule 13.4, advisory])
    +e9084                   /* assignment used inside larger
                                expression */
    +elib(9084)
    -append(9084,[MISRA C:2023 Rule 13.4, advisory])

/**** Rule 13.5 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e9007                              /* side effects on right hand side of logical operator */
    +elib(9007)
    -append(9007,[MISRA C:2023 Rule 13.5, required])

/**** Rule 13.6 (Req) ************/

    +e9006                              /* sizeof used with expression with side effect */
    +elib(9006)
    -append(9006,[MISRA C:2023 Rule 13.6, required])

/**** Rule 14.1 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e9009                              /* floating point variable used as loop counter */
    +elib(9009)
    -append(9009,[MISRA C:2023 Rule 14.1, required])

/**** Rule 14.2 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */

    +e850                               /* for loop counter modified in body */
    +elib(850)
    -append(850,[MISRA C:2023 Rule 14.2, required])

    +e9191                              /* multiple for loop counters */
    +elib(9191)
    -append(9191,[MISRA C:2023 Rule 14.2, required])

    +e9192                              /* no for loop counters */
    +elib(9192)
    -append(9192,[MISRA C:2023 Rule 14.2, required])
    -estring(9192,"empty")

    +e9194                              /* variable modified in for condition/expression isn't a loop counter */
    +elib(9194)
    -append(9194,[MISRA C:2023 Rule 14.2, required])

    +e9195                              /* variable potentially modified in for condition/expression isn't a loop counter */
    +elib(9195)
    -append(9195,[MISRA C:2023 Rule 14.2, required])

    +e9196                              /* non-loop counter variable modified in for body isn't bool */
    +elib(9196)
    -append(9196,[MISRA C:2023 Rule 14.2, required])

    +e9197                              /* statement in for loop init-statement that doesn't assign the value of a loop counter */
    +elib(9197)
    -append(9197,[MISRA C:2023 Rule 14.2, required])

/**** Rule 14.3 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e685			/* relational always evaluates to true/false */
    +elib(685)
    -append(685,[MISRA C:2023 Rule 14.3, required])
    +e774			/* boolean always evaluates to true/false */
    +elib(774)
    -append(774,[MISRA C:2023 Rule 14.3, required])
    +e650			/* constant out of range for operator */
    +elib(650)
    -append(650,[MISRA C:2023 Rule 14.3, required])

/**** Rule 14.4 (Req) ************/

    +e9036                              /* condition should have essentially Boolean type */
    +elib(9036)
    -append(9036,[MISRA C:2023 Rule 14.4, required])

/**** Rule 15.1 (Adv) ************/

    +e801       /* use of 'goto' is deprecated */
    +elib(801)
    -append(801,[MISRA C:2023 Rule 15.1, advisory])

/**** Rule 15.2 (Req) ************/

    +e9064      /* goto references earlier label */
    +elib(9064)
    -append(9064,[MISRA C:2023 Rule 15.2, required])

/**** Rule 15.3 (Req) ************/

    +e9041                      /* goto not nested in the same block as label */
    +elib(9041)
    -append(9041,[MISRA C:2023 Rule 15.3, required])

/**** Rule 15.4 (Adv) ************/

    +e9011                              /* more than one 'break' terminates loop */
    +elib(9011)
    -append(9011,[MISRA C:2023 Rule 15.4, advisory])

/**** Rule 15.5 (Adv) ************/

    +e904                   /* return before function end */
    +elib(904)
    -append(904,[MISRA C:2023 Rule 15.5, advisory])

/**** Rule 15.6 (Req) ************/

    +e9012                   /* sub-statement should be a compound statement */
    +elib(9012)
    -append(9012,[MISRA C:2023 Rule 15.6, required])

/**** Rule 15.7 (Req) ************/

    +e9013                   /* no 'else' at end of 'if ... else if' chain */
    +elib(9013)
    -append(9013,[MISRA C:2023 Rule 15.7, required])
    +e9063                   /* no comment or action in else-branch */
    +elib(9063)
    -append(9063,[MISRA C:2023 Rule 15.7, required])

/**** Rule 16.1 (Req) ************/

    +e616                  /* control flows into case/default */
    +elib(616)
    -append(616,[MISRA C:2023 Rule 16.1, required])
    +e744                  /* switch statement has no default */
    +elib(744)
    -append(744,[MISRA C:2023 Rule 16.1, required])
    +e764                  /* switch does not have a case */
    +elib(764)
    -append(764,[MISRA C:2023 Rule 16.1, required])
    +e825                  /* control flows into case/default without -fallthrough comment */
    +elib(825)
    -append(825,[MISRA C:2023 Rule 16.1, required])
    +e9014                 /* default missing from switch */
    +elib(9014)
    -append(9014,[MISRA C:2023 Rule 16.1, required])
    +e9042                 /* departure from MISRA switch syntax */
    +elib(9042)
    -append(9042,[MISRA C:2023 Rule 16.1, required])
    +e9077                 /* missing unconditional break */
    +elib(9077)
    -append(9077,[MISRA C:2023 Rule 16.1, required])
    +e9081                 /* too few independent cases for switch */
    +elib(9081)
    -append(9081,[MISRA C:2023 Rule 16.1, required])
    +e9082                 /* switch statement should either begin or end with default label */
    +elib(9082)
    -append(9082,[MISRA C:2023 Rule 16.1, required])
    +e9085                 /* statement or comment should appear in default case */
    +elib(9085)
    -append(9085,[MISRA C:2023 Rule 16.1, required])

/**** Rule 16.2 (Req) ************/

    +e44                  /* Need a switch */
    +elib(44)
    -append(44,[MISRA C:2023 Rule 16.2, required])
    +e9055                /* enclosing statement is not a switch */
    +elib(9055)
    -append(9055,[MISRA C:2023 Rule 16.2, required])

/**** Rule 16.3 (Req) ************/

    +e616                 /* control flows into case/default */
    +elib(616)
    -append(616,[MISRA C:2023 Rule 16.3, required])
    +e825                 /* control flows into case/default without -fallthrough comment */
    +elib(825)
    -append(825,[MISRA C:2023 Rule 16.3, required])
    +e9077                /* missing unconditional break */
    +elib(9077)
    -append(9077,[MISRA C:2023 Rule 16.3, required])
    +e9090                /* missing unconditional break */
    +elib(9090)
    -append(9090,[MISRA C:2023 Rule 16.3, required])

/**** Rule 16.4 (Req) ************/

    +e744            /* switch statement has no default */
    +elib(744)
    -append(744,[MISRA C:2023 Rule 16.4, required])
    +e9014            /* switch statement has no default */
    +elib(9014)
    -append(9014,[MISRA C:2023 Rule 16.4, required])
    +e9085            /* default case has no statement nor comment */
    +elib(9085)
    -append(9085,[MISRA C:2023 Rule 16.4, required])

/**** Rule 16.5 (Req) ************/

    +e9082                   /* default should be first or last */
    +elib(9082)
    -append(9082,[MISRA C:2023 Rule 16.5, required])

/**** Rule 16.6 (Req) ************/

    +e764            /* switch does not have a case */
    +elib(764)
    -append(764,[MISRA C:2023 Rule 16.6, required])
    +e9081           /* too few cases */
    +elib(9081)
    -append(9081,[MISRA C:2023 Rule 16.6, required])

/**** Rule 16.7 (Req) ************/

    +e483                   /* boolean value in switch expression */
    +elib(483)
    -append(483,[MISRA C:2023 Rule 16.7, required])

/**** Rule 17.1 (Req) ************/

    +e829       /* warn on header usage */
    +elib(829)
    +headerwarn(stdarg.h)
    -append(829(stdarg.h),[MISRA C:2023 Rule 17.1, required])

    -deprecate(macro,va_arg)
    -append(586(va_arg),[MISRA C:2023 Rule 17.1, required])
    -deprecate(macro,va_start)
    -append(586(va_start),[MISRA C:2023 Rule 17.1, required])
    -deprecate(macro,va_end)
    -append(586(va_end),[MISRA C:2023 Rule 17.1, required])
    -deprecate(macro,va_copy)
    -append(586(va_copy),[MISRA C:2023 Rule 17.1, required])
    -deprecate(type,va_list)
    -append(586(va_list),[MISRA C:2023 Rule 17.1, required])

/**** Rule 17.2 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e9070
    -append(9070,[MISRA C:2023 Rule 17.2, required])

/**** Rule 17.3 (Mand) ************/

    +e718  	      		 /* symbol undeclared, assumed to return int */
    +elib(718)
    -append(718,[MISRA C:2023 Rule 17.3, mandatory])

/**** Rule 17.4 (Mand) ************/

    +e533                /* function should return a value */
    +elib(533)
    -append(533,[MISRA C:2023 Rule 17.4, mandatory])

/**** Rule 17.5 (Req) ************/

    /* MISRA has declared this rule to be "undecidable". */

    +e473                /* argument to array parameter too small */
    +elib(473)
    -append(473,[MISRA C:2023 Rule 17.5, required])

/**** Rule 17.6 (Mand) ************/

    +e9043                   /* static between brackets of array declaration */
    +elib(9043)
    -append(9043,[MISRA C:2023 Rule 17.6, mandatory])

/**** Rule 17.7 (Req) ************/

    +e534               /* ignoring return value of function */
    +elib(534)
    -append(534,[MISRA C:2023 Rule 17.7, required])

/**** Rule 17.8 (Adv) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e9044               /* function parameter modified */
    +elib(9044)
    -append(9044,[MISRA C:2023 Rule 17.8, advisory])

/**** Rule 17.9 (Mand) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */

    +e2436       /* function declared 'noreturn' should not return */
    +elib(2436)
    -append(2436,[MISRA C:2023 Rule 17.9, mandatory])

/**** Rule 17.10 (Req) ************/

    +e841        /* function is declared as noreturn but returns a value */
    +elib(841)
    -append(841,[MISRA C:2023 Rule 17.10, required])

/**** Rule 17.11 (Adv) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */

    +e2707       /* function could be declared as 'noreturn' */
    +elib(2707)
    -append(2707,[MISRA C:2023 Rule 17.11, advisory])

/**** Rule 17.12 (Adv) ************/

    +e9147       /* implicit function-to-pointer decay */
    +elib(9147)
    -append(9147,[MISRA C:2023 Rule 17.12, advisory])

/**** Rule 17.13 (Req) ************/

    +e2417        /* const/volatile on function type */
    +elib(2417)
    -append(2417,[MISRA C:2023 Rule 17.13, required])

    +e4175        /* _Atomic cannot be applied to function type */
    +elib(4175)
    -append(4175,[MISRA C:2023 Rule 17.13, required])

    +e5805        /* restrict requires a pointer or reference */
    +elib(5805)
    -append(5805,[MISRA C:2023 Rule 17.13, required])

/**** Rule 18.1 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e415          /* out-of-bounds pointer */
    +elib(415)
    -append(415,[MISRA C:2023 Rule 18.1, required])
    +e416          /* out-of-bounds pointer */
    +elib(416)
    -append(416,[MISRA C:2023 Rule 18.1, required])
    +e428          /* out-of-bounds pointer */
    +elib(428)
    -append(428,[MISRA C:2023 Rule 18.1, required])
    +e661          /* out-of-bounds pointer */
    +elib(661)
    -append(661,[MISRA C:2023 Rule 18.1, required])
    +e662          /* out-of-bounds pointer */
    +elib(662)
    -append(662,[MISRA C:2023 Rule 18.1, required])
    +e676          /* out-of-bounds pointer */
    +elib(676)
    -append(676,[MISRA C:2023 Rule 18.1, required])

/**** Rule 18.2 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e947          /* pointer subtraction */
    +elib(947)
    -append(947,[MISRA C:2023 Rule 18.2, required])

/**** Rule 18.3 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e946          /* relational operator applied to pointers */
    +elib(946)
    -append(946,[MISRA C:2023 Rule 18.3, required])

/**** Rule 18.4 (Adv) ************/

    +e9016                   /* pointer arithmetic other than array indexing used */
    +elib(9016)
    -append(9016,[MISRA C:2023 Rule 18.4, advisory])

/**** Rule 18.5 (Adv) ************/

    +e9025                   /* more than two pointer indirection levels used */
    +elib(9025)
    -append(9025,[MISRA C:2023 Rule 18.5, advisory])

/**** Rule 18.6 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e733               /* assigning address of auto to outer scope symbol */
    +elib(733)
    -append(733,[MISRA C:2023 Rule 18.6, required])
    +e789               /* assigning address of auto to static */
    +elib(789)
    -append(789,[MISRA C:2023 Rule 18.6, required])
    +e604               /* returning address of auto variable */
    +elib(604)
    -append(604,[MISRA C:2023 Rule 18.6, required])

/**** Rule 18.7 (Req) ************/

    +e9038                   /* flexible array member declared */
    +elib(9038)
    -append(9038,[MISRA C:2023 Rule 18.7, required])

/**** Rule 18.8 (Req) ************/

    +e9035                   /* variable length array declared */
    +elib(9035)
    -append(9035,[MISRA C:2023 Rule 18.8, required])

/**** Rule 18.9 (Req) ************/

    +e9188        /* improper handling of temporary array */
    +elib(9188)
    -append(9188,[MISRA C:2023 Rule 18.9, required])

/**** Rule 18.10 (Mand) ************/

    +e2708     /* pointer to variably-modified array type */
    +elib(2708)
    -append(2708,[MISRA C:2023 Rule 18.10, mandatory])

/**** Rule 19.1 (Mand) ************/

    +e464                    /* buffer arguments in call to function overlap */
    +elib(464)
    -append(464,[MISRA C:2023 Rule 19.1, mandatory])

    +e2507                   /* assignment between overlapping objects is not well defined */
    +elib(2507)
    -append(2507,[MISRA C:2023 Rule 19.1, mandatory])

/**** Rule 19.2 (Adv) ************/

    +e9018                   /* union type/object declared */
    +elib(9018)
    -append(9018,[MISRA C:2023 Rule 19.2, advisory])

/**** Rule 20.1 (Adv) ************/

    +e9019                   /* declaration before #include */
    +elib(9019)
    -append(9019,[MISRA C:2023 Rule 20.1, advisory])

/**** Rule 20.2 (Req) ************/

    +e9020                   /* header file name with non-standard character */
    +elib(9020)
    -append(9020,[MISRA C:2023 Rule 20.2, required])
    /*  Note: If your system requires the '\' be used as a directory
        separator, uncomment the following option.
     */
    //  -estring(9020,\)

/**** Rule 20.3 (Req) ************/

    +e12                    /* Need < or " after #include */
    +elib(12)
    -append(12,[MISRA C:2023 Rule 20.3, required])

    /* 544  directive not followed by EOL */
    +estring(544,include)
    +elib(544)
    -append(544(include),[MISRA C:2023 Rule 20.3, required])

/**** Rule 20.4 (Req) ************/

    +e9051                              /* macro with same name as a keyword */
    +elib(9051)
    -append(9051,[MISRA C:2023 Rule 20.4, required])

/**** Rule 20.5 (Adv) ************/

    +e9021                   /* use of '#undef' is discouraged */
    +elib(9021)
    -append(9021,[MISRA C:2023 Rule 20.5, advisory])

/**** Rule 20.6 (Req) ************/

    +e436   /* preprocessor directive in invocation of macro */
    +elib(436)
    -append(436,[MISRA C:2023 Rule 20.6, required])

/**** Rule 20.7 (Req) ************/

    +e665                   /* expression passed to unparenthesized macro */
    +elib(665)
    -append(665,[MISRA C:2023 Rule 20.7, required])

/**** Rule 20.8 (Req) ************/

    +e9037                  /* conditional of #if/#elif does not evaluate to 0 or 1 */
    +elib(9037)
    -append(9037,[MISRA C:2023 Rule 20.8, required])

/**** Rule 20.9 (Req) ************/

    +e553   /* Undefined preprocessor variable, assumed 0 */
    +elib(553)
    -append(553,[MISRA C:2023 Rule 20.9, required])

/**** Rule 20.10 (Adv) ************/

    +e9024                   /* '#/##' operators used */
    +elib(9024)
    -append(9024,[MISRA C:2023 Rule 20.10, advisory])

/**** Rule 20.11 (Req) ************/

    +e484                   /* stringize operator followed by macro parameter followed by pasting operator */
    +elib(484)
    -append(484,[MISRA C:2023 Rule 20.11, required])

/**** Rule 20.12 (Req) ************/

    +e9015                   /* macro parameter used with and without '#/##' subject to further replacement */
    +elib(9015)
    -append(9015,[MISRA C:2023 Rule 20.12, required])

/**** Rule 20.13 (Req) ************/

    /* 544 - directive not followed by EOL */
    +e544
    +elib(544)
    -append(544,[MISRA C:2023 Rule 20.13, required])

    /* 16 - unknown preprocessor directive */
    +e16
    +elib(16)
    -append(16,[MISRA C:2023 Rule 20.13, required])

    /* 9160 - unknown preprocessor directive in conditionally excluded
            region */
    +e9160
    +elib(9160)
    -append(9160,[MISRA C:2023 Rule 20.13, required])

/**** Rule 20.14 (Req) ************/

    +e8       /* unclosed #if */
    +elib(8)
    -append(8,[MISRA C:2023 Rule 20.14, required])

/**** Rule 21.1 (Req) ************/

    +e136       /* Illegal macro name */
    +elib(136)
    -append(136,[MISRA C:2023 Rule 21.1, required])
    /*  Undefining standard library macros is covered by rule 20.5.  */
    /*  Defining/redefining reserved/standard identifiers is covered
        by rules 20.4 and 21.2.
     */
    +e9071      /* defined macro reserved to the compiler */
    +elib(9071)
    -append(9071,[MISRA C:2023 Rule 21.1, required])
    // explicit exemptions
    -estring(9071,* because *)
    -estring(9071,cerf)
    -estring(9071,cerfc)
    -estring(9071,cexp2)
    -estring(9071,cexpm1)
    -estring(9071,clog10)
    -estring(9071,clog1p)
    -estring(9071,clog2)
    -estring(9071,clgamma)
    -estring(9071,ctgamma)
    -estring(9071,cerff)
    -estring(9071,cerfcf)
    -estring(9071,cexp2f)
    -estring(9071,cexpm1f)
    -estring(9071,clog10f)
    -estring(9071,clog1pf)
    -estring(9071,clog2f)
    -estring(9071,clgammaf)
    -estring(9071,ctgammaf)
    -estring(9071,cerfl)
    -estring(9071,cerfcl)
    -estring(9071,cexp2l)
    -estring(9071,cexpm1l)
    -estring(9071,clog10l)
    -estring(9071,clog1pl)
    -estring(9071,clog2l)
    -estring(9071,clgammal)
    -estring(9071,ctgammal)
    -estring(9071,E0*)
    -estring(9071,E1*)
    -estring(9071,E2*)
    -estring(9071,E3*)
    -estring(9071,E4*)
    -estring(9071,E5*)
    -estring(9071,E6*)
    -estring(9071,E7*)
    -estring(9071,E8*)
    -estring(9071,E9*)
    -estring(9071,NDEBUG)
    -estring(9071,PRIa*)
    -estring(9071,PRIb*)
    -estring(9071,PRIc*)
    -estring(9071,PRId*)
    -estring(9071,PRIe*)
    -estring(9071,PRIf*)
    -estring(9071,PRIg*)
    -estring(9071,PRIh*)
    -estring(9071,PRIi*)
    -estring(9071,PRIj*)
    -estring(9071,PRIk*)
    -estring(9071,PRIl*)
    -estring(9071,PRIm*)
    -estring(9071,PRIn*)
    -estring(9071,PRIo*)
    -estring(9071,PRIp*)
    -estring(9071,PRIq*)
    -estring(9071,PRIr*)
    -estring(9071,PRIs*)
    -estring(9071,PRIt*)
    -estring(9071,PRIu*)
    -estring(9071,PRIv*)
    -estring(9071,PRIw*)
    -estring(9071,PRIx*)
    -estring(9071,PRIy*)
    -estring(9071,PRIz*)
    -estring(9071,PRIX*)
    -estring(9071,SCNa*)
    -estring(9071,SCNb*)
    -estring(9071,SCNc*)
    -estring(9071,SCNd*)
    -estring(9071,SCNe*)
    -estring(9071,SCNf*)
    -estring(9071,SCNg*)
    -estring(9071,SCNh*)
    -estring(9071,SCNi*)
    -estring(9071,SCNj*)
    -estring(9071,SCNk*)
    -estring(9071,SCNl*)
    -estring(9071,SCNm*)
    -estring(9071,SCNn*)
    -estring(9071,SCNo*)
    -estring(9071,SCNp*)
    -estring(9071,SCNq*)
    -estring(9071,SCNr*)
    -estring(9071,SCNs*)
    -estring(9071,SCNt*)
    -estring(9071,SCNu*)
    -estring(9071,SCNv*)
    -estring(9071,SCNw*)
    -estring(9071,SCNx*)
    -estring(9071,SCNy*)
    -estring(9071,SCNz*)
    -estring(9071,SCNX*)
    +e9083      /* undefined macro reserved to the compiler */
    +elib(9083)
    -append(9083,[MISRA C:2023 Rule 21.1, required])
    // explicit exemptions
    -estring(9083,* because *)
    -estring(9083,cerf)
    -estring(9083,cerfc)
    -estring(9083,cexp2)
    -estring(9083,cexpm1)
    -estring(9083,clog10)
    -estring(9083,clog1p)
    -estring(9083,clog2)
    -estring(9083,clgamma)
    -estring(9083,ctgamma)
    -estring(9083,cerff)
    -estring(9083,cerfcf)
    -estring(9083,cexp2f)
    -estring(9083,cexpm1f)
    -estring(9083,clog10f)
    -estring(9083,clog1pf)
    -estring(9083,clog2f)
    -estring(9083,clgammaf)
    -estring(9083,ctgammaf)
    -estring(9083,cerfl)
    -estring(9083,cerfcl)
    -estring(9083,cexp2l)
    -estring(9083,cexpm1l)
    -estring(9083,clog10l)
    -estring(9083,clog1pl)
    -estring(9083,clog2l)
    -estring(9083,clgammal)
    -estring(9083,ctgammal)
    -estring(9083,E0*)
    -estring(9083,E1*)
    -estring(9083,E2*)
    -estring(9083,E3*)
    -estring(9083,E4*)
    -estring(9083,E5*)
    -estring(9083,E6*)
    -estring(9083,E7*)
    -estring(9083,E8*)
    -estring(9083,E9*)
    -estring(9083,NDEBUG)
    -estring(9083,PRIa*)
    -estring(9083,PRIb*)
    -estring(9083,PRIc*)
    -estring(9083,PRId*)
    -estring(9083,PRIe*)
    -estring(9083,PRIf*)
    -estring(9083,PRIg*)
    -estring(9083,PRIh*)
    -estring(9083,PRIi*)
    -estring(9083,PRIj*)
    -estring(9083,PRIk*)
    -estring(9083,PRIl*)
    -estring(9083,PRIm*)
    -estring(9083,PRIn*)
    -estring(9083,PRIo*)
    -estring(9083,PRIp*)
    -estring(9083,PRIq*)
    -estring(9083,PRIr*)
    -estring(9083,PRIs*)
    -estring(9083,PRIt*)
    -estring(9083,PRIu*)
    -estring(9083,PRIv*)
    -estring(9083,PRIw*)
    -estring(9083,PRIx*)
    -estring(9083,PRIy*)
    -estring(9083,PRIz*)
    -estring(9083,PRIX*)
    -estring(9083,SCNa*)
    -estring(9083,SCNb*)
    -estring(9083,SCNc*)
    -estring(9083,SCNd*)
    -estring(9083,SCNe*)
    -estring(9083,SCNf*)
    -estring(9083,SCNg*)
    -estring(9083,SCNh*)
    -estring(9083,SCNi*)
    -estring(9083,SCNj*)
    -estring(9083,SCNk*)
    -estring(9083,SCNl*)
    -estring(9083,SCNm*)
    -estring(9083,SCNn*)
    -estring(9083,SCNo*)
    -estring(9083,SCNp*)
    -estring(9083,SCNq*)
    -estring(9083,SCNr*)
    -estring(9083,SCNs*)
    -estring(9083,SCNt*)
    -estring(9083,SCNu*)
    -estring(9083,SCNv*)
    -estring(9083,SCNw*)
    -estring(9083,SCNx*)
    -estring(9083,SCNy*)
    -estring(9083,SCNz*)
    -estring(9083,SCNX*)

/**** Rule 21.2 (Req) ************/

    +e9093      /* name is reserved to the compiler */
    +elib(9093)
    -append(9093,[MISRA C:2023 Rule 21.2, required])

/**** Rule 21.3 (Req) ************/

    +e586       /* Symbol is deprecated */
    +elib(586)
    -deprecate(function,calloc)
    -append(586(calloc),[MISRA C:2023 Rule 21.3, required])
    -deprecate(macro,calloc)
    -append(586(calloc),[MISRA C:2023 Rule 21.3, required])
    -deprecate(function,malloc)
    -append(586(malloc),[MISRA C:2023 Rule 21.3, required])
    -deprecate(macro,malloc)
    -append(586(malloc),[MISRA C:2023 Rule 21.3, required])
    -deprecate(function,realloc)
    -append(586(realloc),[MISRA C:2023 Rule 21.3, required])
    -deprecate(macro,realloc)
    -append(586(realloc),[MISRA C:2023 Rule 21.3, required])
    -deprecate(function,free)
    -append(586(free),[MISRA C:2023 Rule 21.3, required])
    -deprecate(macro,free)
    -append(586(free),[MISRA C:2023 Rule 21.3, required])

    -deprecate(function,aligned_alloc)
    -append(586(aligned_alloc),[MISRA C:2023 Rule 21.3, required])
    -deprecate(macro,aligned_alloc)
    -append(586(aligned_alloc),[MISRA C:2023 Rule 21.3, required])

/**** Rule 21.4 (Req) ************/

    +e829       /* warn on header usage */
    +elib(829)
    +headerwarn(setjmp.h)
    -append(829(setjmp.h),[MISRA C:2023 Rule 21.4, required])

    -deprecate(function,setjmp)
    -append(586(setjmp),[MISRA C:2023 Rule 21.4, required])
    -deprecate(function,longjmp)
    -append(586(longjmp),[MISRA C:2023 Rule 21.4, required])
    -deprecate(macro,setjmp)
    -append(586(setjmp),[MISRA C:2023 Rule 21.4, required])
    -deprecate(macro,longjmp)
    -append(586(longjmp),[MISRA C:2023 Rule 21.4, required])
    -deprecate(type,jmp_buf)
    -append(586(jmp_buf),[MISRA C:2023 Rule 21.4, required])

/**** Rule 21.5 (Req) ************/

    +e829       /* warn on header usage */
    +elib(829)
    +headerwarn(signal.h)
    -append(829(signal.h),[MISRA C:2023 Rule 21.5, required])

    +e586       /* Symbol is deprecated */
    +elib(586)
    -deprecate(function,signal)
    -append(586(signal),[MISRA C:2023 Rule 21.5, required])
    -deprecate(function,raise)
    -append(586(raise),[MISRA C:2023 Rule 21.5, required])
    -deprecate(macro,SIGABRT)
    -append(586(SIGABRT),[MISRA C:2023 Rule 21.5, required])
    -deprecate(macro,SIGFPE)
    -append(586(SIGFPE),[MISRA C:2023 Rule 21.5, required])
    -deprecate(macro,SIGILL)
    -append(586(SIGILL),[MISRA C:2023 Rule 21.5, required])
    -deprecate(macro,SIGINT)
    -append(586(SIGINT),[MISRA C:2023 Rule 21.5, required])
    -deprecate(macro,SIGSEGV)
    -append(586(SIGSEGV),[MISRA C:2023 Rule 21.5, required])
    -deprecate(macro,SIGTERM)
    -append(586(SIGTERM),[MISRA C:2023 Rule 21.5, required])
    -deprecate(macro,SIG_DFL)
    -append(586(SIG_DFL),[MISRA C:2023 Rule 21.5, required])
    -deprecate(macro,SIG_ERR)
    -append(586(SIG_ERR),[MISRA C:2023 Rule 21.5, required])
    -deprecate(macro,SIG_IGN)
    -append(586(SIG_IGN),[MISRA C:2023 Rule 21.5, required])
    -deprecate(type,sig_atomic_t)
    -append(586(sig_atomic_t),[MISRA C:2023 Rule 21.5, required])

/**** Rule 21.6 (Req) ************/

    +e586       /* Symbol is deprecated */
    +elib(586)
    -deprecate(function,clearerr)
    -append(586(clearerr),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fclose)
    -append(586(fclose),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,feof)
    -append(586(feof),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,ferror)
    -append(586(ferror),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fflush)
    -append(586(fflush),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fgetc)
    -append(586(fgetc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fgetpos)
    -append(586(fgetpos),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fgets)
    -append(586(fgets),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fgetwc)
    -append(586(fgetwc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fgetws)
    -append(586(fgetws),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fopen)
    -append(586(fopen),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fprintf)
    -append(586(fprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fputc)
    -append(586(fputc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fputs)
    -append(586(fputs),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fputwc)
    -append(586(fputwc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fputws)
    -append(586(fputws),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fread)
    -append(586(fread),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fscanf)
    -append(586(fscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fseek)
    -append(586(fseek),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fsetpos)
    -append(586(fsetpos),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,freopen)
    -append(586(freopen),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,ftell)
    -append(586(ftell),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fwide)
    -append(586(fwide),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fwprintf)
    -append(586(fwprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fwrite)
    -append(586(fwrite),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,fwscanf)
    -append(586(fwscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,getc)
    -append(586(getc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,getchar)
    -append(586(getchar),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,gets)
    -append(586(gets),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,getwc)
    -append(586(getwc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,getwchar)
    -append(586(getwchar),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,perror)
    -append(586(perror),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,printf)
    -append(586(printf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,putc)
    -append(586(putc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,putchar)
    -append(586(putchar),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,puts)
    -append(586(puts),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,putwc)
    -append(586(putwc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,putwchar)
    -append(586(putwchar),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,remove)
    -append(586(remove),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,rename)
    -append(586(rename),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,rewind)
    -append(586(rewind),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,scanf)
    -append(586(scanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,setbuf)
    -append(586(setbuf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,setvbuf)
    -append(586(setvbuf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,snprintf)
    -append(586(snprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,sprintf)
    -append(586(sprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,sscanf)
    -append(586(sscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,swprintf)
    -append(586(swprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,swscanf)
    -append(586(swscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,tmpfile)
    -append(586(tmpfile),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,tmpnam)
    -append(586(tmpnam),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,ungetc)
    -append(586(ungetc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,ungetwc)
    -append(586(ungetwc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,vfprintf)
    -append(586(vfprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,vfscanf)
    -append(586(vfscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,vfwprintf)
    -append(586(vfwprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,vfwscanf)
    -append(586(vfwscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,vprintf)
    -append(586(vprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,vscanf)
    -append(586(vscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,vsnprintf)
    -append(586(vsnprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,vsprintf)
    -append(586(vsprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,vsscanf)
    -append(586(vsscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,vswprintf)
    -append(586(vswprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,vswscanf)
    -append(586(vswscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,vwprintf)
    -append(586(vwprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,vwscanf)
    -append(586(vwscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,wprintf)
    -append(586(wprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(function,wscanf)
    -append(586(wscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,clearerr)
    -append(586(clearerr),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fclose)
    -append(586(fclose),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,feof)
    -append(586(feof),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,ferror)
    -append(586(ferror),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fflush)
    -append(586(fflush),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fgetc)
    -append(586(fgetc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fgets)
    -append(586(fgets),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fgetpos)
    -append(586(fgetpos),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fgetwc)
    -append(586(fgetwc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fgetws)
    -append(586(fgetws),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fopen)
    -append(586(fopen),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fprintf)
    -append(586(fprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fputc)
    -append(586(fputc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fputs)
    -append(586(fputs),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fputwc)
    -append(586(fputwc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fputws)
    -append(586(fputws),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fread)
    -append(586(fread),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fscanf)
    -append(586(fscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fseek)
    -append(586(fseek),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fsetpos)
    -append(586(fsetpos),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,freopen)
    -append(586(freopen),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,ftell)
    -append(586(ftell),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fwide)
    -append(586(fwide),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fwprintf)
    -append(586(fwprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fwrite)
    -append(586(fwrite),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,fwscanf)
    -append(586(fwscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,getc)
    -append(586(getc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,getchar)
    -append(586(getchar),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,gets)
    -append(586(gets),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,getwc)
    -append(586(getwc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,getwchar)
    -append(586(getwchar),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,perror)
    -append(586(perror),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,printf)
    -append(586(printf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,putc)
    -append(586(putc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,putchar)
    -append(586(putchar),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,puts)
    -append(586(puts),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,putwc)
    -append(586(putwc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,putwchar)
    -append(586(putwchar),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,remove)
    -append(586(remove),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,rename)
    -append(586(rename),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,rewind)
    -append(586(rewind),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,scanf)
    -append(586(scanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,setbuf)
    -append(586(setbuf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,setvbuf)
    -append(586(setvbuf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,snprintf)
    -append(586(snprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,sprintf)
    -append(586(sprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,sscanf)
    -append(586(sscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,swprintf)
    -append(586(swprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,swscanf)
    -append(586(swscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,tmpfile)
    -append(586(tmpfile),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,tmpnam)
    -append(586(tmpnam),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,ungetc)
    -append(586(ungetc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,ungetwc)
    -append(586(ungetwc),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,vfprintf)
    -append(586(vfprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,vfscanf)
    -append(586(vfscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,vfwprintf)
    -append(586(vfwprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,vfwscanf)
    -append(586(vfwscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,vprintf)
    -append(586(vprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,vscanf)
    -append(586(vscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,vsnprintf)
    -append(586(vsnprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,vsprintf)
    -append(586(vsprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,vsscanf)
    -append(586(vsscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,vswprintf)
    -append(586(vswprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,vswscanf)
    -append(586(vswscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,vwprintf)
    -append(586(vwprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,vwscanf)
    -append(586(vwscanf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,wprintf)
    -append(586(wprintf),[MISRA C:2023 Rule 21.6, required])
    -deprecate(macro,wscanf)
    -append(586(wscanf),[MISRA C:2023 Rule 21.6, required])

/**** Rule 21.7 (Req) ************/

    +e586       /* Symbol is deprecated */
    +elib(586)
    -deprecate(function,atof)
    -append(586(atof),[MISRA C:2023 Rule 21.7, required])
    -deprecate(function,atoi)
    -append(586(atoi),[MISRA C:2023 Rule 21.7, required])
    -deprecate(function,atol)
    -append(586(atol),[MISRA C:2023 Rule 21.7, required])
    -deprecate(function,atoll)
    -append(586(atoll),[MISRA C:2023 Rule 21.7, required])
    -deprecate(macro,atof)
    -append(586(atof),[MISRA C:2023 Rule 21.7, required])
    -deprecate(macro,atoi)
    -append(586(atoi),[MISRA C:2023 Rule 21.7, required])
    -deprecate(macro,atol)
    -append(586(atol),[MISRA C:2023 Rule 21.7, required])
    -deprecate(macro,atoll)
    -append(586(atoll),[MISRA C:2023 Rule 21.7, required])

/**** Rule 21.8 (Req) ************/

    +e586       /* Symbol is deprecated */
    +elib(586)
    -deprecate(function,abort)
    -append(586(abort),[MISRA C:2023 Rule 21.8, required])
    -deprecate(function,exit)
    -append(586(exit),[MISRA 2023 Rule 21.8, required])
    -deprecate(macro,abort)
    -append(586(abort),[MISRA C:2023 Rule 21.8, required])
    -deprecate(macro,exit)
    -append(586(exit),[MISRA 2023 Rule 21.8, required])

    -deprecate(function,_Exit)
    -append(586(_Exit),[MISRA C:2023 Rule 21.8, required])
    -deprecate(function,quick_exit)
    -append(586(quick_exit),[MISRA C:2023 Rule 21.8, required])
    -deprecate(macro,_Exit)
    -append(586(_Exit),[MISRA C:2023 Rule 21.8, required])
    -deprecate(macro,quick_exit)
    -append(586(quick_exit),[MISRA C:2023 Rule 21.8, required])

/**** Rule 21.9 (Req) ************/

    +e586       /* Symbol is deprecated */
    +elib(586)
    -deprecate(function,bsearch)
    -append(586(bsearch),[MISRA C:2023 Rule 21.9, required])
    -deprecate(function,qsort)
    -append(586(qsort),[MISRA C:2023 Rule 21.9, required])
    -deprecate(macro,bsearch)
    -append(586(bsearch),[MISRA C:2023 Rule 21.9, required])
    -deprecate(macro,qsort)
    -append(586(qsort),[MISRA C:2023 Rule 21.9, required])

/**** Rule 21.10 (Req) ************/

    +e829       /* warn on header usage */
    +elib(829)
    +headerwarn(time.h)
    -append(829(time.h),[MISRA C:2023 Rule 21.10, required])

    +e586       /* Symbol is deprecated */
    +elib(586)
    -deprecate(macro,wcsftime)
    -append(586(wcsftime),[MISRA C:2023 Rule 21.10, required])
    -deprecate(function,wcsftime)
    -append(586(wcsftime),[MISRA C:2023 Rule 21.10, required])
    -deprecate(macro,clock)
    -append(586(clock),[MISRA C:2023 Rule 21.10, required])
    -deprecate(function,clock)
    -append(586(clock),[MISRA C:2023 Rule 21.10, required])
    -deprecate(macro,difftime)
    -append(586(difftime),[MISRA C:2023 Rule 21.10, required])
    -deprecate(function,difftime)
    -append(586(difftime),[MISRA C:2023 Rule 21.10, required])
    -deprecate(macro,mktime)
    -append(586(mktime),[MISRA C:2023 Rule 21.10, required])
    -deprecate(function,mktime)
    -append(586(mktime),[MISRA C:2023 Rule 21.10, required])
    -deprecate(macro,time)
    -append(586(time),[MISRA C:2023 Rule 21.10, required])
    -deprecate(function,time)
    -append(586(time),[MISRA C:2023 Rule 21.10, required])
    -deprecate(macro,asctime)
    -append(586(asctime),[MISRA C:2023 Rule 21.10, required])
    -deprecate(function,asctime)
    -append(586(asctime),[MISRA C:2023 Rule 21.10, required])
    -deprecate(macro,ctime)
    -append(586(ctime),[MISRA C:2023 Rule 21.10, required])
    -deprecate(function,ctime)
    -append(586(ctime),[MISRA C:2023 Rule 21.10, required])
    -deprecate(macro,gmtime)
    -append(586(gmtime),[MISRA C:2023 Rule 21.10, required])
    -deprecate(function,gmtime)
    -append(586(gmtime),[MISRA C:2023 Rule 21.10, required])
    -deprecate(macro,localtime)
    -append(586(localtime),[MISRA C:2023 Rule 21.10, required])
    -deprecate(function,localtime)
    -append(586(localtime),[MISRA C:2023 Rule 21.10, required])
    -deprecate(macro,strftime)
    -append(586(strftime),[MISRA C:2023 Rule 21.10, required])
    -deprecate(function,strftime)
    -append(586(strftime),[MISRA C:2023 Rule 21.10, required])
    -deprecate(macro,CLOCKS_PER_SEC)
    -append(586(CLOCKS_PER_SEC),[MISRA C:2023 Rule 21.10, required])
    -deprecate(type,clock_t)
    -append(586(clock_t),[MISRA C:2023 Rule 21.10, required])
    -deprecate(type,time_t)
    -append(586(time_t),[MISRA C:2023 Rule 21.10, required])
    -deprecate(type,struct tm)
    -append(586(struct tm),[MISRA C:2023 Rule 21.10, required])

/**** Rule 21.11 (Adv) ************/

    +e829       /* warn on header usage */
    +elib(829)
    +headerwarn(tgmath.h)
    -append(829(tgmath.h),[MISRA C:2023 Rule 21.11, advisory])

/**** Rule 21.12 (Req) ************/

    +e829       /* warn on header usage */
    +elib(829)
    +headerwarn(fenv.h)
    -append(829(fenv.h),[MISRA C:2023 Rule 21.11, required])

    +e586       /* Symbol is deprecated */
    +elib(586)
    -deprecate(function,feclearexcept)
    -append(586(feclearexcept),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,feclearexcept)
    -append(586(feclearexcept),[MISRA C:2023 Rule 21.12, required])
    -deprecate(function,fegetexceptflag)
    -append(586(fegetexceptflag),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,fegetexceptflag)
    -append(586(fegetexceptflag),[MISRA C:2023 Rule 21.12, required])
    -deprecate(function,feraiseexcept)
    -append(586(feraiseexcept),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,feraiseexcept)
    -append(586(feraiseexcept),[MISRA C:2023 Rule 21.12, required])
    -deprecate(function,fesetexceptflag)
    -append(586(fesetexceptflag),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,fesetexceptflag)
    -append(586(fesetexceptflag),[MISRA C:2023 Rule 21.12, required])
    -deprecate(function,fetestexcept)
    -append(586(fetestexcept),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,fetestexcept)
    -append(586(fetestexcept),[MISRA C:2023 Rule 21.12, required])
    -deprecate(function,fegetround)
    -append(586(fegetround),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,fegetround)
    -append(586(fegetround),[MISRA C:2023 Rule 21.12, required])
    -deprecate(function,fesetround)
    -append(586(fesetround),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,fesetround)
    -append(586(fesetround),[MISRA C:2023 Rule 21.12, required])
    -deprecate(function,fegetenv)
    -append(586(fegetenv),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,fegetenv)
    -append(586(fegetenv),[MISRA C:2023 Rule 21.12, required])
    -deprecate(function,feholdexcept)
    -append(586(feholdexcept),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,feholdexcept)
    -append(586(feholdexcept),[MISRA C:2023 Rule 21.12, required])
    -deprecate(function,fesetenv)
    -append(586(fesetenv),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,fesetenv)
    -append(586(fesetenv),[MISRA C:2023 Rule 21.12, required])
    -deprecate(function,feupdateenv)
    -append(586(feupdateenv),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,feupdateenv)
    -append(586(feupdateenv),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,FE_INEXACT)
    -append(586(FE_INEXACT),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,FE_DIVBYZERO)
    -append(586(FE_DIVBYZERO),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,FE_UNDERFLOW)
    -append(586(FE_UNDERFLOW),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,FE_OVERFLOW)
    -append(586(FE_OVERFLOW),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,FE_INVALID)
    -append(586(FE_INVALID),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,FE_ALL_EXCEPT)
    -append(586(FE_ALL_EXCEPT),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,FE_DOWNWARD)
    -append(586(FE_DOWNWARD),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,FE_TONEAREST)
    -append(586(FE_TONEAREST),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,FE_TOWARDZERO)
    -append(586(FE_TOWARDZERO),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,FE_UPWARD)
    -append(586(FE_UPWARD),[MISRA C:2023 Rule 21.12, required])
    -deprecate(macro,FE_DFL_ENV)
    -append(586(FE_DFL_ENV),[MISRA C:2023 Rule 21.12, required])
    -deprecate(type,fenv_t)
    -append(586(fenv_t),[MISRA C:2023 Rule 21.12, required])
    -deprecate(type,fexcept_t)
    -append(586(fexcept_t),[MISRA C:2023 Rule 21.12, required])

/**** Rule 21.13 (Mand) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */

    /* Define EOF until a proper definition is seen */
    -dEOF=-1

    /* Define UCHAR_MIN and UCHAR_MAX if no definition available */
    -dUCHAR_MIN=0
    -dUCHAR_MAX=255

    /* Ensure macro versions of ctype.h functions expand to function versions
       to make use of the function semantics defined below */
    --uisalnum
    --uisalpha
    --uisblank
    --uiscntrl
    --uisdigit
    --uisgraph
    --uislower
    --uisprint
    --uispunct
    --uisspace
    --uisupper
    --uisxdigit
    --utolower
    --utoupper

    /* Define semantics for ctype.h functions */
    -sem(isalnum, (1n >= UCHAR_MIN && 1n <= UCHAR_MAX) || 1n == EOF)
    -sem(isalpha, (1n >= UCHAR_MIN && 1n <= UCHAR_MAX) || 1n == EOF)
    -sem(isblank, (1n >= UCHAR_MIN && 1n <= UCHAR_MAX) || 1n == EOF)
    -sem(iscntrl, (1n >= UCHAR_MIN && 1n <= UCHAR_MAX) || 1n == EOF)
    -sem(isdigit, (1n >= UCHAR_MIN && 1n <= UCHAR_MAX) || 1n == EOF)
    -sem(isgraph, (1n >= UCHAR_MIN && 1n <= UCHAR_MAX) || 1n == EOF)
    -sem(islower, (1n >= UCHAR_MIN && 1n <= UCHAR_MAX) || 1n == EOF)
    -sem(isprint, (1n >= UCHAR_MIN && 1n <= UCHAR_MAX) || 1n == EOF)
    -sem(ispunct, (1n >= UCHAR_MIN && 1n <= UCHAR_MAX) || 1n == EOF)
    -sem(isspace, (1n >= UCHAR_MIN && 1n <= UCHAR_MAX) || 1n == EOF)
    -sem(isupper, (1n >= UCHAR_MIN && 1n <= UCHAR_MAX) || 1n == EOF)
    -sem(isxdigit, (1n >= UCHAR_MIN && 1n <= UCHAR_MAX) || 1n == EOF)
    -sem(tolower, (1n >= UCHAR_MIN && 1n <= UCHAR_MAX) || 1n == EOF)
    -sem(toupper, (1n >= UCHAR_MIN && 1n <= UCHAR_MAX) || 1n == EOF)

    +esym(426, isalnum)
    +esym(426, isalpha)
    +esym(426, isblank)
    +esym(426, iscntrl)
    +esym(426, isdigit)
    +esym(426, isgraph)
    +esym(426, islower)
    +esym(426, isprint)
    +esym(426, ispunct)
    +esym(426, isspace)
    +esym(426, isupper)
    +esym(426, isxdigit)
    +esym(426, tolower)
    +esym(426, toupper)

    -append(426(isalnum), value passed to isalnum is not representable as unsigned char and is not EOF)
    -append(426(isalnum),[MISRA C:2023 Rule 21.13, mandatory])

    -append(426(isalpha), value passed to isalpha is not representable as unsigned char and is not EOF)
    -append(426(isalpha),[MISRA C:2023 Rule 21.13, mandatory])

    -append(426(isblank), value passed to isblank is not representable as unsigned char and is not EOF)
    -append(426(isblank),[MISRA C:2023 Rule 21.13, mandatory])

    -append(426(iscntrl), value passed to iscntrl is not representable as unsigned char and is not EOF)
    -append(426(iscntrl),[MISRA C:2023 Rule 21.13, mandatory])

    -append(426(isdigit), value passed to isdigit is not representable as unsigned char and is not EOF)
    -append(426(isdigit),[MISRA C:2023 Rule 21.13, mandatory])

    -append(426(isgraph), value passed to isgraph is not representable as unsigned char and is not EOF)
    -append(426(isgraph),[MISRA C:2023 Rule 21.13, mandatory])

    -append(426(islower), value passed to islower is not representable as unsigned char and is not EOF)
    -append(426(islower),[MISRA C:2023 Rule 21.13, mandatory])

    -append(426(isprint), value passed to isprint is not representable as unsigned char and is not EOF)
    -append(426(isprint),[MISRA C:2023 Rule 21.13, mandatory])

    -append(426(ispunct), value passed to ispunct is not representable as unsigned char and is not EOF)
    -append(426(ispunct),[MISRA C:2023 Rule 21.13, mandatory])

    -append(426(isspace), value passed to isspace is not representable as unsigned char and is not EOF)
    -append(426(isspace),[MISRA C:2023 Rule 21.13, mandatory])

    -append(426(isupper), value passed to isupper is not representable as unsigned char and is not EOF)
    -append(426(isupper),[MISRA C:2023 Rule 21.13, mandatory])

    -append(426(isxdigit), value passed to isxdigit is not representable as unsigned char and is not EOF)
    -append(426(isxdigit),[MISRA C:2023 Rule 21.13, mandatory])

    -append(426(tolower), value passed to tolower is not representable as unsigned char and is not EOF)
    -append(426(tolower),[MISRA C:2023 Rule 21.13, mandatory])

    -append(426(toupper), value passed to toupper is not representable as unsigned char and is not EOF)
    -append(426(toupper),[MISRA C:2023 Rule 21.13, mandatory])

/**** Rule 21.14 (Req) ************/

    /* Not currently supported */

/**** Rule 21.15 (Req) ************/

    +e857	  	    /* incompatible pointer arguments to memcpy/memmove/memcmp */
    +elib(857)
    -append(857,[MISRA C:2023 Rule 21.15, required])

/**** Rule 21.16 (Req) ************/

    +e9098  	    /* pointer argument to memcmp does not point to a pointer type
                       or an essentially signed, unsigned, boolean, or enum type */
    +elib(9098)
    -append(9098,[MISRA C:2023 Rule 21.16, required])

/**** Rule 21.17 (Mand) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */

    /* 419 - apparent data overrun for function */
    /* 420 - apparent access beyond array for function */

    +esym(419 420, strcat, strcpy)
    -append(419(strcat),[MISRA C:2023 Rule 21.17, mandatory])
    -append(420(strcat),[MISRA C:2023 Rule 21.17, mandatory])
    -append(419(strcpy),[MISRA C:2023 Rule 21.17, mandatory])
    -append(420(strcpy),[MISRA C:2023 Rule 21.17, mandatory])

/**** Rule 21.18 (Mand) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */

    /* 419 - apparent data overrun for function */
    /* 420 - apparent access beyond array for function */
    /* 422 - function passed a negative value */

    +esym(419 420 422, memchr, memcmp, memcpy, memmove, memset)
    +esym(419 420 422, strncat, strncmp, strncpy, strxfrm)

    /* PC-lint Plus will issue 419 when it can determine that
     * the size parameter of the below functions exceeds the
     * size of the buffer that is being written to.
     */

    -append(419(memcpy),[MISRA C:2023 Rule 21.18, mandatory])
    -append(419(memmove),[MISRA C:2023 Rule 21.18, mandatory])
    -append(419(strncat),[MISRA C:2023 Rule 21.18, mandatory])
    -append(419(strncpy),[MISRA C:2023 Rule 21.18, mandatory])

    /* PC-lint Plus will issue 420 when it can determine that
     * the size parameter of the below functions exceeds the
     * size of the buffer that is being read from.
     */

    -append(420(memchr),[MISRA C:2023 Rule 21.18, mandatory])
    -append(420(memcmp),[MISRA C:2023 Rule 21.18, mandatory])
    -append(420(memcpy),[MISRA C:2023 Rule 21.18, mandatory])
    -append(420(memmove),[MISRA C:2023 Rule 21.18, mandatory])

    /* PC-lint Plus will issue 422 when it can determine that
     * a negative value is being passed to the size parameter
     * of the below functions.
     */

    -append(422(memchr),[MISRA C:2023 Rule 21.18, mandatory])
    -append(422(memcmp),[MISRA C:2023 Rule 21.18, mandatory])
    -append(422(memcpy),[MISRA C:2023 Rule 21.18, mandatory])
    -append(422(memmove),[MISRA C:2023 Rule 21.18, mandatory])
    -append(422(memset),[MISRA C:2023 Rule 21.18, mandatory])
    -append(422(strncat),[MISRA C:2023 Rule 21.18, mandatory])
    -append(422(strncmp),[MISRA C:2023 Rule 21.18, mandatory])
    -append(422(strncpy),[MISRA C:2023 Rule 21.18, mandatory])
    -append(422(strxfrm),[MISRA C:2023 Rule 21.18, mandatory])

/**** Rule 21.19 (Mand) ************/

    +e2721      /* pointer returned from function, whose value should not be modified, is assigned to pointer to non-const */
    +elib(2721)
    -append(2721,[MISRA C:2023 Rule 21.19, mandatory])

    +etype(9223, const struct lconv *) /* value is modified using a pointer member of a const-qualified base */
    +elib(9223)
    -append(9223,[MISRA C:2023 Rule 21.19, mandatory])

/**** Rule 21.20 (Mand) ************/

    /* Not currently supported */

/**** Rule 21.21 (Req) ************/

    +e586        /* to activate the deprecation message */
    +elib(586)

    -deprecate(function,system)
    -append(586(system),[MISRA C:2023 Rule 21.21, required])
    -deprecate(macro,system)
    -append(586(system),[MISRA C:2023 Rule 21.21, required])

/**** Rule 21.22 (Mand) ************/

    +e9504 /* argument supplied to type-generic macro has an inappropriate essential type */
    +elib(9504)
    -append(9504,[MISRA C:2023 Rule 21.22, mandatory])

/**** Rule 21.23 (Req) ************/

    +e9218 /* arguments to type-generic macro resulting in call to function have different types */
    +elib(9218)
    -append(9218,[MISRA C:2023 Rule 21.23, required])

/**** Rule 21.24 (Req) ************/

    +e586        /* to activate the deprecation message */
    +elib(586)

    -deprecate(function,rand)
    -append(586(rand),[MISRA C:2023 Rule 21.24, required])
    -deprecate(function,srand)
    -append(586(srand),[MISRA C:2023 Rule 21.24, required])
    -deprecate(macro,rand)
    -append(586(rand),[MISRA C:2023 Rule 21.24, required])
    -deprecate(macro,srand)
    -append(586(srand),[MISRA C:2023 Rule 21.24, required])

/**** Rule 21.25 (Req) ************/

    /* Not currently supported */

/**** Rule 21.26 (Req) ************/

    /* Not currently supported */

/**** Rule 22.1 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e429       /* custodial pointer neither free'd nor returned */
    +elib(429)
    -append(429,[MISRA C:2023 Rule 22.1, required])

    /* 698 - in-place realloc could cause a memory leak */
    +e698
    +elib(698)
    -append(698,[MISRA C:2023 Rule 22.1, required])

/**** Rule 22.2 (Mand) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e424       /* inappropriate deallocation */
    +elib(424)
    -append(424,[MISRA C:2023 Rule 22.2, mandatory])

    +e449       /* pointer previously deallocated */
    +elib(449)
    -append(449,[MISRA C:2023 Rule 22.2, mandatory])

/**** Rule 22.3 (Req) ************/

    /* MISRA has declared this rule to be "undecidable". */

/**** Rule 22.4 (Mand) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */

    +e2477   /* attempt to perform write operation on stream not opened for writing */
    +elib(2477)
    -append(2477,[MISRA C:2023 Rule 22.4, mandatory])

/**** Rule 22.5 (Mand) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    +e9047   /* FILE pointer dereferenced */
    +elib(9047)
    -append(9047,[MISRA C:2023 Rule 22.5, mandatory])


/**** Rule 22.6 (Mand) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */

    +e2471   /* operation on stream that has been closed */
    +elib(2471)
    -append(2471,[MISRA C:2023 Rule 22.6, mandatory])

/**** Rule 22.7 (Req) ************/

    /* Not currently supported */

/**** Rule 22.8 (Req) ************/

    /* Not currently supported */

/**** Rule 22.9 (Req) ************/

    /* Not currently supported */

/**** Rule 22.10 (Req) ************/

    /* Not currently supported */

/**** Rule 22.11 (Req) ************/

    /* Not currently supported */

/**** Rule 22.12 (Mand) ************/

    /* Not currently supported */

/**** Rule 22.13 (Req) ************/

    +e2751     /* issued for uses of local mutexes, PC-lint Plus currently expects mutexes to have static storage duration */
    +elib(2751)
    -append(2751,[MISRA C:2023 Rule 22.13, required])


/**** Rule 22.14 (Mand) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */ 

    +e2770      /* type of mutex is incomplete but its usage requires specific type */
    +elib(2770)
    -append(2770,[MISRA C:2023 Rule 22.14, mandatory])

    +e2771      /* type of mutex is incomplete */
    +elib(2771)
    -append(2771,[MISRA C:2023 Rule 22.14, mandatory])

/**** Rule 22.15 (Req) ************/

    /* Not currently supported */

/**** Rule 22.16 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    
    +e454     /* mutex 'symbol' locked without being unlocked */
    +elib(454)
    -append(454,[MISRA C:2023 Rule 22.16, required])

/**** Rule 22.17 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    
    +e455     /* mutex 'symbol' unlocked without being locked */
    +elib(455)
    -append(455,[MISRA C:2023 Rule 22.17, required])

    +ecall(2495, cnd_wait, cnd_timedwait)   /* mutex not locked */
    +elib(2495)
    -append(2495,[MISRA C:2023 Rule 22.17, required])

/**** Rule 22.18 (Req) ************/

    /* While MISRA has declared this rule to be "undecidable", the
     * following options are provided to assist:
     */
    
    +e2457     /* non-recursive mutex locked recursively */
    +elib(2457)
    -append(2457,[MISRA C:2023 Rule 22.18, required])

/**** Rule 22.19 (Req) ************/

    /* Not currently supported */

/**** Rule 22.20 (Mand) ************/

    /* Not currently supported */

/**** Rule 23.1 (Adv) ************/

    +e9211       /* generic selection is not expanded from a function-like macro */
    +elib(9211)
    -append(9211,[MISRA C:2023 Rule 23.1, advisory])

/**** Rule 23.2 (Req) ************/

    +e2419       /* controlling expression contains a side effect */
    +elib(2419)
    -append(2419,[MISRA C:2023 Rule 23.2, required])

    +e9213       /* controlling expression contains a call to function which will not be called */
    +elib(9213)
    -append(9213,[MISRA C:2023 Rule 23.2, required])

/**** Rule 23.3 (Adv) ************/

    +e9208 /* generic selection does not contain any non-default associations */
    +elib(9208)
    -append(9208,[MISRA C:2023 Rule 23.3, advisory])

/**** Rule 23.4 (Req) ************/

    +e2416 /* generic selection association type that will never be eligible for selection */
    +elib(2416)
    -append(2416,[MISRA C:2023 Rule 23.4, required])

/**** Rule 23.5 (Adv) ************/

    +e9214 /* generic selection selects default because pointer type is not implicitly converted */
    +elib(9214)
    -append(9214,[MISRA C:2023 Rule 23.5, advisory])

/**** Rule 23.6 (Req) ************/

    +e9216 /* essential type of the controlling expression does not match its standard type */
    +elib(9216)
    -append(9216,[MISRA C:2023 Rule 23.6, required])

/**** Rule 23.7 (Adv) ************/

    +e9219 /* parameter of generic selection macro is not evaluated exactly once */
    +elib(9219)
    -append(9219,[MISRA C:2023 Rule 23.7, advisory])

/**** Rule 23.8 (Req) ************/

    +e9210       /* default association does not appear as either the first or the last association of generic selection */
    +elib(9210)
    -append(9210,[MISRA C:2023 Rule 23.8, required])
